pragma solidity >=0.7.0 <0.9.0;

import "./SdiVerifier.sol";
import "../precompiles/ComplianceBridge.sol";
import "@openzeppelin/contracts/access/Ownable.sol";

/**
 * @title AirdropSDI Contract
 * @author Your Name/Organisation (or remove if not applicable)
 * @notice Manages Selective Disclosure Identifiers (SDI) for airdrops, including verification logic,
 * Merkle root updates, and issuer management.
 * @dev This contract relies on a PlonkVerifier for ZK-proof verification (though verification logic isn't shown here)
 * and manages Merkle roots for issuance and revocation trees related to SDIs. It uses Ownable for access control.
 */
contract AirdropSDI is Ownable {
    /// @notice Emitted when the issuance and revocation Merkle roots are updated.
    /// @param issuanceRoot The new root hash of the issuance Merkle tree.
    /// @param revocationRoot The new root hash of the revocation Merkle tree.
    event RootsUpdated(bytes32 issuanceRoot, bytes32 revocationRoot);

    /// @notice Emitted when an issuer's permissions are revoked.
    /// @param issuer The address of the revoked issuer.
    event IssuerRevoked(address issuer);

    /// @notice Emitted when a new issuer is granted permissions.
    /// @param issuer The address of the newly added issuer.
    event IssuerAdded(address issuer);

    /// @notice Emitted when a user successfully verifies their proof and is marked as eligible for the airdrop.
    /// @param user The address of the user who became eligible.
    event AddedToEligible(address user);

    /// @notice Mapping storing addresses that have successfully verified and are eligible for the airdrop.
    /// @dev Key is the user's address, value is true if eligible, false otherwise. Checked in `claimAirdrop`.
    mapping (address => bool) public isEligible;

    /// @notice Array of allowed issuers
    address[] public allowedIssuers;

    /// @notice The address of the PlonkVerifier contract used for proof verification.
    PlonkVerifier public verifier;

    /// @notice The current Merkle root for the SDI issuance tree.
    bytes32 public issuanceRoot;
    /// @notice The current Merkle root for the SDI revocation tree.
    bytes32 public revocationRoot;

    /**
     * @notice Initializes the AirdropSDI contract.
     * @dev Sets the Plonk verifier contract address, initializes the list of allowed issuers,
     * and sets the deployer as the contract owner using the Ownable constructor.
     * @param _verifier The address of the PlonkVerifier contract used for proof verification.
     * @param _allowedIssuers An array of addresses initially designated as allowed issuers.
     */
    constructor (PlonkVerifier _verifier, address[] memory _allowedIssuers) Ownable(msg.sender) {
        verifier = _verifier;

        require(_allowedIssuers.length != 0, "Allowed issuers cannot be empty");
        require(!_containsDuplicates(_allowedIssuers), "Contains duplicated issuer");
        allowedIssuers = _allowedIssuers;
    }

    /**
     * @notice Allows a user to claim the airdrop by submitting a ZK proof and public signals.
     * @dev Verifies that the user hasn't claimed before, that the contract roots and issuers are initialized,
     * and calls the `PlonkVerifier` contract to verify the submitted proof against the public signals.
     * If verification is successful, marks the sender (`msg.sender`) as eligible and emits the {AddedToEligible} event.
     * Assumes the public signals include commitments related to the `issuanceRoot`, `revocationRoot`, and potentially `allowedIssuers`.
     * @param _proof The ZK proof bytes generated by the user.
     * @param _publicSignals The public signals corresponding to the proof, used by the verifier.
     */
    function claimAirdrop(bytes calldata _proof, uint[] memory _publicSignals) public {
        require(!isEligible[msg.sender], "User was already verified");

        // Check if contract was initialized
        require(issuanceRoot != bytes32(0), "Issuance root not set");
        require(revocationRoot != bytes32(0), "Revocation root not set");
        require(allowedIssuers.length != 0, "Empty allowed issuers");

        // Call verifier contract to verify user proof
        require(verifier.verifyProof(_proof, _publicSignals), "Proof verification failed");

        isEligible[msg.sender] = true;

        emit AddedToEligible(msg.sender);
    }

    /**
     * @notice Updates the issuance and revocation Merkle roots.
     * @dev Allows the owner to set new root hashes for the Merkle trees used in SDI verification.
     * Emits a {RootsUpdated} event upon successful update.
     * Requires owner privileges via the `onlyOwner` modifier.
     * @param _issuanceRoot The new Merkle root for the issuance tree.
     * @param _revocationRoot The new Merkle root for the revocation tree.
     */
    function updateRoots(bytes32 _issuanceRoot, bytes32 _revocationRoot) public onlyOwner {
        issuanceRoot = _issuanceRoot;
        revocationRoot = _revocationRoot;

        emit RootsUpdated(_issuanceRoot, _revocationRoot);
    }

    /**
     * @notice Adds a new issuer to the allowed list.
     * @dev Allows the owner to grant issuer privileges to a specified address.
     * Reverts with message "Issuer already exists" if the address is already an allowed issuer.
     * Emits an {IssuerAdded} event upon successful addition.
     * Requires owner privileges via the `onlyOwner` modifier.
     * @param _issuer The address to designate as an allowed issuer.
     */
    function addAllowedIssuer(address _issuer) public onlyOwner {
        require(!_issuerExists(_issuer), "Issuer already exists");

        allowedIssuers.push(_issuer);

        emit IssuerAdded(_issuer);
    }

    /**
     * @notice Revokes issuer privileges from an address.
     * @dev Allows the owner to remove an address from the list of allowed issuers.
     * Reverts with message "Issuer not found" if the address is not currently an allowed issuer.
     * Emits an {IssuerRevoked} event upon successful revocation.
     * Requires owner privileges via the `onlyOwner` modifier.
     * @param issuer The address whose issuer privileges are to be revoked.
     */
    function revokeAllowedIssuer(address issuer) public onlyOwner {
        uint256 issuerIndex = 0;
        bool found = false;
        
        for (uint256 i = 0; i < allowedIssuers.length; i++) {
            if (allowedIssuers[i] == issuer) {
                issuerIndex = i;
                found = true;
                break;
            }
        }
        
        require(found, "Issuer not found");
        
        // If the issuer is not the last element, swap with the last element
        if (issuerIndex < allowedIssuers.length - 1) {
            allowedIssuers[issuerIndex] = allowedIssuers[allowedIssuers.length - 1];
        }
        
        allowedIssuers.pop();
        
        emit IssuerRevoked(issuer);
    }

    /**
    * @notice Checks if an array of addresses contains any duplicates
    * @dev Uses a nested loop approach with O(nÂ²) time complexity to identify duplicates
    * @dev Early returns false for arrays with 0 or 1 elements as they cannot contain duplicates
    * @dev Early returns true as soon as the first duplicate is found
    * @param items The array of addresses to check for duplicates
    * @return bool True if at least one duplicate is found, false otherwise
    */
    function _containsDuplicates(address[] memory items) private pure returns (bool) {
        uint256 length = items.length;
        
        if (length <= 1) {
            return false;
        }

        for (uint256 i = 0; i < length - 1; i++) {
            for (uint256 j = i + 1; j < length; j++) {
                if (items[i] == items[j]) {
                    return true;
                }
            }
        }
        
        return false;
    }


    /**
    * @dev Checks if an address exists in an array of allowed issuers
    * @param addr The address to search for
    * @return bool True if the address is found, false otherwise
    */
    function _issuerExists(address addr) private view returns (bool) {
        for (uint256 i = 0; i < allowedIssuers.length; i++) {
            if (allowedIssuers[i] == addr) {
                return true;
            }
        }
        
        return false;
    }
}