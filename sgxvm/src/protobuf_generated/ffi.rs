// This file is generated by rust-protobuf 2.8.1. Do not edit
// @generated

// https://github.com/Manishearth/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![cfg_attr(rustfmt, rustfmt_skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unsafe_code)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `proto/ffi.proto`



use std::prelude::v1::*;
use protobuf::Message as Message_imported_for_functions;
use protobuf::ProtobufEnum as ProtobufEnum_imported_for_functions;

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_8_1;

#[derive(PartialEq,Clone,Default)]
pub struct AccessListItem {
    // message fields
    pub storageSlot: ::protobuf::RepeatedField<::std::vec::Vec<u8>>,
    pub address: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AccessListItem {
    fn default() -> &'a AccessListItem {
        <AccessListItem as ::protobuf::Message>::default_instance()
    }
}

impl AccessListItem {
    pub fn new() -> AccessListItem {
        ::std::default::Default::default()
    }

    // repeated bytes storageSlot = 1;


    pub fn get_storageSlot(&self) -> &[::std::vec::Vec<u8>] {
        &self.storageSlot
    }
    pub fn clear_storageSlot(&mut self) {
        self.storageSlot.clear();
    }

    // Param is passed by value, moved
    pub fn set_storageSlot(&mut self, v: ::protobuf::RepeatedField<::std::vec::Vec<u8>>) {
        self.storageSlot = v;
    }

    // Mutable pointer to the field.
    pub fn mut_storageSlot(&mut self) -> &mut ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        &mut self.storageSlot
    }

    // Take field
    pub fn take_storageSlot(&mut self) -> ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        ::std::mem::replace(&mut self.storageSlot, ::protobuf::RepeatedField::new())
    }

    // bytes address = 2;


    pub fn get_address(&self) -> &[u8] {
        &self.address
    }
    pub fn clear_address(&mut self) {
        self.address.clear();
    }

    // Param is passed by value, moved
    pub fn set_address(&mut self, v: ::std::vec::Vec<u8>) {
        self.address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_address(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.address
    }

    // Take field
    pub fn take_address(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.address, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for AccessListItem {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_bytes_into(wire_type, is, &mut self.storageSlot)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.address)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.storageSlot {
            my_size += ::protobuf::rt::bytes_size(1, &value);
        };
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.address);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.storageSlot {
            os.write_bytes(1, &v)?;
        };
        if !self.address.is_empty() {
            os.write_bytes(2, &self.address)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AccessListItem {
        AccessListItem::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "storageSlot",
                    |m: &AccessListItem| { &m.storageSlot },
                    |m: &mut AccessListItem| { &mut m.storageSlot },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "address",
                    |m: &AccessListItem| { &m.address },
                    |m: &mut AccessListItem| { &mut m.address },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AccessListItem>(
                    "AccessListItem",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AccessListItem {
        static mut instance: ::protobuf::lazy::Lazy<AccessListItem> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AccessListItem,
        };
        unsafe {
            instance.get(AccessListItem::new)
        }
    }
}

impl ::protobuf::Clear for AccessListItem {
    fn clear(&mut self) {
        self.storageSlot.clear();
        self.address.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AccessListItem {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AccessListItem {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TransactionData {
    // message fields
    pub from: ::std::vec::Vec<u8>,
    pub to: ::std::vec::Vec<u8>,
    pub data: ::std::vec::Vec<u8>,
    pub gasLimit: u64,
    pub value: ::std::vec::Vec<u8>,
    pub accessList: ::protobuf::RepeatedField<AccessListItem>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TransactionData {
    fn default() -> &'a TransactionData {
        <TransactionData as ::protobuf::Message>::default_instance()
    }
}

impl TransactionData {
    pub fn new() -> TransactionData {
        ::std::default::Default::default()
    }

    // bytes from = 1;


    pub fn get_from(&self) -> &[u8] {
        &self.from
    }
    pub fn clear_from(&mut self) {
        self.from.clear();
    }

    // Param is passed by value, moved
    pub fn set_from(&mut self, v: ::std::vec::Vec<u8>) {
        self.from = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_from(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.from
    }

    // Take field
    pub fn take_from(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.from, ::std::vec::Vec::new())
    }

    // bytes to = 2;


    pub fn get_to(&self) -> &[u8] {
        &self.to
    }
    pub fn clear_to(&mut self) {
        self.to.clear();
    }

    // Param is passed by value, moved
    pub fn set_to(&mut self, v: ::std::vec::Vec<u8>) {
        self.to = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_to(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.to
    }

    // Take field
    pub fn take_to(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.to, ::std::vec::Vec::new())
    }

    // bytes data = 3;


    pub fn get_data(&self) -> &[u8] {
        &self.data
    }
    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.data
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.data, ::std::vec::Vec::new())
    }

    // uint64 gasLimit = 4;


    pub fn get_gasLimit(&self) -> u64 {
        self.gasLimit
    }
    pub fn clear_gasLimit(&mut self) {
        self.gasLimit = 0;
    }

    // Param is passed by value, moved
    pub fn set_gasLimit(&mut self, v: u64) {
        self.gasLimit = v;
    }

    // bytes value = 5;


    pub fn get_value(&self) -> &[u8] {
        &self.value
    }
    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::vec::Vec<u8>) {
        self.value = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.value
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.value, ::std::vec::Vec::new())
    }

    // repeated .ffi.ffi.AccessListItem accessList = 6;


    pub fn get_accessList(&self) -> &[AccessListItem] {
        &self.accessList
    }
    pub fn clear_accessList(&mut self) {
        self.accessList.clear();
    }

    // Param is passed by value, moved
    pub fn set_accessList(&mut self, v: ::protobuf::RepeatedField<AccessListItem>) {
        self.accessList = v;
    }

    // Mutable pointer to the field.
    pub fn mut_accessList(&mut self) -> &mut ::protobuf::RepeatedField<AccessListItem> {
        &mut self.accessList
    }

    // Take field
    pub fn take_accessList(&mut self) -> ::protobuf::RepeatedField<AccessListItem> {
        ::std::mem::replace(&mut self.accessList, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for TransactionData {
    fn is_initialized(&self) -> bool {
        for v in &self.accessList {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.from)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.to)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.data)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.gasLimit = tmp;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.value)?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.accessList)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.from.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.from);
        }
        if !self.to.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.to);
        }
        if !self.data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.data);
        }
        if self.gasLimit != 0 {
            my_size += ::protobuf::rt::value_size(4, self.gasLimit, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.value.is_empty() {
            my_size += ::protobuf::rt::bytes_size(5, &self.value);
        }
        for value in &self.accessList {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.from.is_empty() {
            os.write_bytes(1, &self.from)?;
        }
        if !self.to.is_empty() {
            os.write_bytes(2, &self.to)?;
        }
        if !self.data.is_empty() {
            os.write_bytes(3, &self.data)?;
        }
        if self.gasLimit != 0 {
            os.write_uint64(4, self.gasLimit)?;
        }
        if !self.value.is_empty() {
            os.write_bytes(5, &self.value)?;
        }
        for v in &self.accessList {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TransactionData {
        TransactionData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "from",
                    |m: &TransactionData| { &m.from },
                    |m: &mut TransactionData| { &mut m.from },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "to",
                    |m: &TransactionData| { &m.to },
                    |m: &mut TransactionData| { &mut m.to },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "data",
                    |m: &TransactionData| { &m.data },
                    |m: &mut TransactionData| { &mut m.data },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "gasLimit",
                    |m: &TransactionData| { &m.gasLimit },
                    |m: &mut TransactionData| { &mut m.gasLimit },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "value",
                    |m: &TransactionData| { &m.value },
                    |m: &mut TransactionData| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AccessListItem>>(
                    "accessList",
                    |m: &TransactionData| { &m.accessList },
                    |m: &mut TransactionData| { &mut m.accessList },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TransactionData>(
                    "TransactionData",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TransactionData {
        static mut instance: ::protobuf::lazy::Lazy<TransactionData> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TransactionData,
        };
        unsafe {
            instance.get(TransactionData::new)
        }
    }
}

impl ::protobuf::Clear for TransactionData {
    fn clear(&mut self) {
        self.from.clear();
        self.to.clear();
        self.data.clear();
        self.gasLimit = 0;
        self.value.clear();
        self.accessList.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TransactionData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TransactionData {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TransactionContext {
    // message fields
    pub chain_id: u64,
    pub gas_price: ::std::vec::Vec<u8>,
    pub timestamp: u64,
    pub block_gas_limit: u64,
    pub block_base_fee_per_gas: ::std::vec::Vec<u8>,
    pub block_coinbase: ::std::vec::Vec<u8>,
    pub block_number: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TransactionContext {
    fn default() -> &'a TransactionContext {
        <TransactionContext as ::protobuf::Message>::default_instance()
    }
}

impl TransactionContext {
    pub fn new() -> TransactionContext {
        ::std::default::Default::default()
    }

    // uint64 chain_id = 1;


    pub fn get_chain_id(&self) -> u64 {
        self.chain_id
    }
    pub fn clear_chain_id(&mut self) {
        self.chain_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_chain_id(&mut self, v: u64) {
        self.chain_id = v;
    }

    // bytes gas_price = 2;


    pub fn get_gas_price(&self) -> &[u8] {
        &self.gas_price
    }
    pub fn clear_gas_price(&mut self) {
        self.gas_price.clear();
    }

    // Param is passed by value, moved
    pub fn set_gas_price(&mut self, v: ::std::vec::Vec<u8>) {
        self.gas_price = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_gas_price(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.gas_price
    }

    // Take field
    pub fn take_gas_price(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.gas_price, ::std::vec::Vec::new())
    }

    // uint64 timestamp = 3;


    pub fn get_timestamp(&self) -> u64 {
        self.timestamp
    }
    pub fn clear_timestamp(&mut self) {
        self.timestamp = 0;
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: u64) {
        self.timestamp = v;
    }

    // uint64 block_gas_limit = 4;


    pub fn get_block_gas_limit(&self) -> u64 {
        self.block_gas_limit
    }
    pub fn clear_block_gas_limit(&mut self) {
        self.block_gas_limit = 0;
    }

    // Param is passed by value, moved
    pub fn set_block_gas_limit(&mut self, v: u64) {
        self.block_gas_limit = v;
    }

    // bytes block_base_fee_per_gas = 5;


    pub fn get_block_base_fee_per_gas(&self) -> &[u8] {
        &self.block_base_fee_per_gas
    }
    pub fn clear_block_base_fee_per_gas(&mut self) {
        self.block_base_fee_per_gas.clear();
    }

    // Param is passed by value, moved
    pub fn set_block_base_fee_per_gas(&mut self, v: ::std::vec::Vec<u8>) {
        self.block_base_fee_per_gas = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_block_base_fee_per_gas(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.block_base_fee_per_gas
    }

    // Take field
    pub fn take_block_base_fee_per_gas(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.block_base_fee_per_gas, ::std::vec::Vec::new())
    }

    // bytes block_coinbase = 6;


    pub fn get_block_coinbase(&self) -> &[u8] {
        &self.block_coinbase
    }
    pub fn clear_block_coinbase(&mut self) {
        self.block_coinbase.clear();
    }

    // Param is passed by value, moved
    pub fn set_block_coinbase(&mut self, v: ::std::vec::Vec<u8>) {
        self.block_coinbase = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_block_coinbase(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.block_coinbase
    }

    // Take field
    pub fn take_block_coinbase(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.block_coinbase, ::std::vec::Vec::new())
    }

    // uint64 block_number = 7;


    pub fn get_block_number(&self) -> u64 {
        self.block_number
    }
    pub fn clear_block_number(&mut self) {
        self.block_number = 0;
    }

    // Param is passed by value, moved
    pub fn set_block_number(&mut self, v: u64) {
        self.block_number = v;
    }
}

impl ::protobuf::Message for TransactionContext {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.chain_id = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.gas_price)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.timestamp = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.block_gas_limit = tmp;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.block_base_fee_per_gas)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.block_coinbase)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.block_number = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.chain_id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.chain_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.gas_price.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.gas_price);
        }
        if self.timestamp != 0 {
            my_size += ::protobuf::rt::value_size(3, self.timestamp, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.block_gas_limit != 0 {
            my_size += ::protobuf::rt::value_size(4, self.block_gas_limit, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.block_base_fee_per_gas.is_empty() {
            my_size += ::protobuf::rt::bytes_size(5, &self.block_base_fee_per_gas);
        }
        if !self.block_coinbase.is_empty() {
            my_size += ::protobuf::rt::bytes_size(6, &self.block_coinbase);
        }
        if self.block_number != 0 {
            my_size += ::protobuf::rt::value_size(7, self.block_number, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.chain_id != 0 {
            os.write_uint64(1, self.chain_id)?;
        }
        if !self.gas_price.is_empty() {
            os.write_bytes(2, &self.gas_price)?;
        }
        if self.timestamp != 0 {
            os.write_uint64(3, self.timestamp)?;
        }
        if self.block_gas_limit != 0 {
            os.write_uint64(4, self.block_gas_limit)?;
        }
        if !self.block_base_fee_per_gas.is_empty() {
            os.write_bytes(5, &self.block_base_fee_per_gas)?;
        }
        if !self.block_coinbase.is_empty() {
            os.write_bytes(6, &self.block_coinbase)?;
        }
        if self.block_number != 0 {
            os.write_uint64(7, self.block_number)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TransactionContext {
        TransactionContext::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "chain_id",
                    |m: &TransactionContext| { &m.chain_id },
                    |m: &mut TransactionContext| { &mut m.chain_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "gas_price",
                    |m: &TransactionContext| { &m.gas_price },
                    |m: &mut TransactionContext| { &mut m.gas_price },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "timestamp",
                    |m: &TransactionContext| { &m.timestamp },
                    |m: &mut TransactionContext| { &mut m.timestamp },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "block_gas_limit",
                    |m: &TransactionContext| { &m.block_gas_limit },
                    |m: &mut TransactionContext| { &mut m.block_gas_limit },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "block_base_fee_per_gas",
                    |m: &TransactionContext| { &m.block_base_fee_per_gas },
                    |m: &mut TransactionContext| { &mut m.block_base_fee_per_gas },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "block_coinbase",
                    |m: &TransactionContext| { &m.block_coinbase },
                    |m: &mut TransactionContext| { &mut m.block_coinbase },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "block_number",
                    |m: &TransactionContext| { &m.block_number },
                    |m: &mut TransactionContext| { &mut m.block_number },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TransactionContext>(
                    "TransactionContext",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TransactionContext {
        static mut instance: ::protobuf::lazy::Lazy<TransactionContext> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TransactionContext,
        };
        unsafe {
            instance.get(TransactionContext::new)
        }
    }
}

impl ::protobuf::Clear for TransactionContext {
    fn clear(&mut self) {
        self.chain_id = 0;
        self.gas_price.clear();
        self.timestamp = 0;
        self.block_gas_limit = 0;
        self.block_base_fee_per_gas.clear();
        self.block_coinbase.clear();
        self.block_number = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TransactionContext {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TransactionContext {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct HandleTransactionRequest {
    // message fields
    pub tx_data: ::protobuf::SingularPtrField<TransactionData>,
    pub tx_context: ::protobuf::SingularPtrField<TransactionContext>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a HandleTransactionRequest {
    fn default() -> &'a HandleTransactionRequest {
        <HandleTransactionRequest as ::protobuf::Message>::default_instance()
    }
}

impl HandleTransactionRequest {
    pub fn new() -> HandleTransactionRequest {
        ::std::default::Default::default()
    }

    // .ffi.ffi.TransactionData tx_data = 1;


    pub fn get_tx_data(&self) -> &TransactionData {
        self.tx_data.as_ref().unwrap_or_else(|| TransactionData::default_instance())
    }
    pub fn clear_tx_data(&mut self) {
        self.tx_data.clear();
    }

    pub fn has_tx_data(&self) -> bool {
        self.tx_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tx_data(&mut self, v: TransactionData) {
        self.tx_data = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tx_data(&mut self) -> &mut TransactionData {
        if self.tx_data.is_none() {
            self.tx_data.set_default();
        }
        self.tx_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_tx_data(&mut self) -> TransactionData {
        self.tx_data.take().unwrap_or_else(|| TransactionData::new())
    }

    // .ffi.ffi.TransactionContext tx_context = 2;


    pub fn get_tx_context(&self) -> &TransactionContext {
        self.tx_context.as_ref().unwrap_or_else(|| TransactionContext::default_instance())
    }
    pub fn clear_tx_context(&mut self) {
        self.tx_context.clear();
    }

    pub fn has_tx_context(&self) -> bool {
        self.tx_context.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tx_context(&mut self, v: TransactionContext) {
        self.tx_context = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tx_context(&mut self) -> &mut TransactionContext {
        if self.tx_context.is_none() {
            self.tx_context.set_default();
        }
        self.tx_context.as_mut().unwrap()
    }

    // Take field
    pub fn take_tx_context(&mut self) -> TransactionContext {
        self.tx_context.take().unwrap_or_else(|| TransactionContext::new())
    }
}

impl ::protobuf::Message for HandleTransactionRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.tx_data {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.tx_context {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.tx_data)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.tx_context)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.tx_data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.tx_context.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.tx_data.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.tx_context.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> HandleTransactionRequest {
        HandleTransactionRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TransactionData>>(
                    "tx_data",
                    |m: &HandleTransactionRequest| { &m.tx_data },
                    |m: &mut HandleTransactionRequest| { &mut m.tx_data },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TransactionContext>>(
                    "tx_context",
                    |m: &HandleTransactionRequest| { &m.tx_context },
                    |m: &mut HandleTransactionRequest| { &mut m.tx_context },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<HandleTransactionRequest>(
                    "HandleTransactionRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static HandleTransactionRequest {
        static mut instance: ::protobuf::lazy::Lazy<HandleTransactionRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const HandleTransactionRequest,
        };
        unsafe {
            instance.get(HandleTransactionRequest::new)
        }
    }
}

impl ::protobuf::Clear for HandleTransactionRequest {
    fn clear(&mut self) {
        self.tx_data.clear();
        self.tx_context.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for HandleTransactionRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HandleTransactionRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct HandleTransactionResponse {
    // message fields
    pub logs: ::protobuf::RepeatedField<Log>,
    pub ret: ::std::vec::Vec<u8>,
    pub vm_error: ::std::string::String,
    pub gas_used: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a HandleTransactionResponse {
    fn default() -> &'a HandleTransactionResponse {
        <HandleTransactionResponse as ::protobuf::Message>::default_instance()
    }
}

impl HandleTransactionResponse {
    pub fn new() -> HandleTransactionResponse {
        ::std::default::Default::default()
    }

    // repeated .ffi.ffi.Log logs = 2;


    pub fn get_logs(&self) -> &[Log] {
        &self.logs
    }
    pub fn clear_logs(&mut self) {
        self.logs.clear();
    }

    // Param is passed by value, moved
    pub fn set_logs(&mut self, v: ::protobuf::RepeatedField<Log>) {
        self.logs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_logs(&mut self) -> &mut ::protobuf::RepeatedField<Log> {
        &mut self.logs
    }

    // Take field
    pub fn take_logs(&mut self) -> ::protobuf::RepeatedField<Log> {
        ::std::mem::replace(&mut self.logs, ::protobuf::RepeatedField::new())
    }

    // bytes ret = 3;


    pub fn get_ret(&self) -> &[u8] {
        &self.ret
    }
    pub fn clear_ret(&mut self) {
        self.ret.clear();
    }

    // Param is passed by value, moved
    pub fn set_ret(&mut self, v: ::std::vec::Vec<u8>) {
        self.ret = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ret(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.ret
    }

    // Take field
    pub fn take_ret(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.ret, ::std::vec::Vec::new())
    }

    // string vm_error = 4;


    pub fn get_vm_error(&self) -> &str {
        &self.vm_error
    }
    pub fn clear_vm_error(&mut self) {
        self.vm_error.clear();
    }

    // Param is passed by value, moved
    pub fn set_vm_error(&mut self, v: ::std::string::String) {
        self.vm_error = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_vm_error(&mut self) -> &mut ::std::string::String {
        &mut self.vm_error
    }

    // Take field
    pub fn take_vm_error(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.vm_error, ::std::string::String::new())
    }

    // uint64 gas_used = 5;


    pub fn get_gas_used(&self) -> u64 {
        self.gas_used
    }
    pub fn clear_gas_used(&mut self) {
        self.gas_used = 0;
    }

    // Param is passed by value, moved
    pub fn set_gas_used(&mut self, v: u64) {
        self.gas_used = v;
    }
}

impl ::protobuf::Message for HandleTransactionResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.logs {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.logs)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.ret)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.vm_error)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.gas_used = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.logs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.ret.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.ret);
        }
        if !self.vm_error.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.vm_error);
        }
        if self.gas_used != 0 {
            my_size += ::protobuf::rt::value_size(5, self.gas_used, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.logs {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.ret.is_empty() {
            os.write_bytes(3, &self.ret)?;
        }
        if !self.vm_error.is_empty() {
            os.write_string(4, &self.vm_error)?;
        }
        if self.gas_used != 0 {
            os.write_uint64(5, self.gas_used)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> HandleTransactionResponse {
        HandleTransactionResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Log>>(
                    "logs",
                    |m: &HandleTransactionResponse| { &m.logs },
                    |m: &mut HandleTransactionResponse| { &mut m.logs },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "ret",
                    |m: &HandleTransactionResponse| { &m.ret },
                    |m: &mut HandleTransactionResponse| { &mut m.ret },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "vm_error",
                    |m: &HandleTransactionResponse| { &m.vm_error },
                    |m: &mut HandleTransactionResponse| { &mut m.vm_error },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "gas_used",
                    |m: &HandleTransactionResponse| { &m.gas_used },
                    |m: &mut HandleTransactionResponse| { &mut m.gas_used },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<HandleTransactionResponse>(
                    "HandleTransactionResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static HandleTransactionResponse {
        static mut instance: ::protobuf::lazy::Lazy<HandleTransactionResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const HandleTransactionResponse,
        };
        unsafe {
            instance.get(HandleTransactionResponse::new)
        }
    }
}

impl ::protobuf::Clear for HandleTransactionResponse {
    fn clear(&mut self) {
        self.logs.clear();
        self.ret.clear();
        self.vm_error.clear();
        self.gas_used = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for HandleTransactionResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HandleTransactionResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Topic {
    // message fields
    pub inner: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Topic {
    fn default() -> &'a Topic {
        <Topic as ::protobuf::Message>::default_instance()
    }
}

impl Topic {
    pub fn new() -> Topic {
        ::std::default::Default::default()
    }

    // bytes inner = 1;


    pub fn get_inner(&self) -> &[u8] {
        &self.inner
    }
    pub fn clear_inner(&mut self) {
        self.inner.clear();
    }

    // Param is passed by value, moved
    pub fn set_inner(&mut self, v: ::std::vec::Vec<u8>) {
        self.inner = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_inner(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.inner
    }

    // Take field
    pub fn take_inner(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.inner, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for Topic {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.inner)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.inner.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.inner);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.inner.is_empty() {
            os.write_bytes(1, &self.inner)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Topic {
        Topic::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "inner",
                    |m: &Topic| { &m.inner },
                    |m: &mut Topic| { &mut m.inner },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Topic>(
                    "Topic",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Topic {
        static mut instance: ::protobuf::lazy::Lazy<Topic> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Topic,
        };
        unsafe {
            instance.get(Topic::new)
        }
    }
}

impl ::protobuf::Clear for Topic {
    fn clear(&mut self) {
        self.inner.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Topic {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Topic {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Log {
    // message fields
    pub address: ::std::vec::Vec<u8>,
    pub topics: ::protobuf::RepeatedField<Topic>,
    pub data: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Log {
    fn default() -> &'a Log {
        <Log as ::protobuf::Message>::default_instance()
    }
}

impl Log {
    pub fn new() -> Log {
        ::std::default::Default::default()
    }

    // bytes address = 1;


    pub fn get_address(&self) -> &[u8] {
        &self.address
    }
    pub fn clear_address(&mut self) {
        self.address.clear();
    }

    // Param is passed by value, moved
    pub fn set_address(&mut self, v: ::std::vec::Vec<u8>) {
        self.address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_address(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.address
    }

    // Take field
    pub fn take_address(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.address, ::std::vec::Vec::new())
    }

    // repeated .ffi.ffi.Topic topics = 2;


    pub fn get_topics(&self) -> &[Topic] {
        &self.topics
    }
    pub fn clear_topics(&mut self) {
        self.topics.clear();
    }

    // Param is passed by value, moved
    pub fn set_topics(&mut self, v: ::protobuf::RepeatedField<Topic>) {
        self.topics = v;
    }

    // Mutable pointer to the field.
    pub fn mut_topics(&mut self) -> &mut ::protobuf::RepeatedField<Topic> {
        &mut self.topics
    }

    // Take field
    pub fn take_topics(&mut self) -> ::protobuf::RepeatedField<Topic> {
        ::std::mem::replace(&mut self.topics, ::protobuf::RepeatedField::new())
    }

    // bytes data = 3;


    pub fn get_data(&self) -> &[u8] {
        &self.data
    }
    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.data
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.data, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for Log {
    fn is_initialized(&self) -> bool {
        for v in &self.topics {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.address)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.topics)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.address);
        }
        for value in &self.topics {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.data);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.address.is_empty() {
            os.write_bytes(1, &self.address)?;
        }
        for v in &self.topics {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.data.is_empty() {
            os.write_bytes(3, &self.data)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Log {
        Log::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "address",
                    |m: &Log| { &m.address },
                    |m: &mut Log| { &mut m.address },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Topic>>(
                    "topics",
                    |m: &Log| { &m.topics },
                    |m: &mut Log| { &mut m.topics },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "data",
                    |m: &Log| { &m.data },
                    |m: &mut Log| { &mut m.data },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Log>(
                    "Log",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Log {
        static mut instance: ::protobuf::lazy::Lazy<Log> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Log,
        };
        unsafe {
            instance.get(Log::new)
        }
    }
}

impl ::protobuf::Clear for Log {
    fn clear(&mut self) {
        self.address.clear();
        self.topics.clear();
        self.data.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Log {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Log {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct QueryGetAccount {
    // message fields
    pub address: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryGetAccount {
    fn default() -> &'a QueryGetAccount {
        <QueryGetAccount as ::protobuf::Message>::default_instance()
    }
}

impl QueryGetAccount {
    pub fn new() -> QueryGetAccount {
        ::std::default::Default::default()
    }

    // bytes address = 1;


    pub fn get_address(&self) -> &[u8] {
        &self.address
    }
    pub fn clear_address(&mut self) {
        self.address.clear();
    }

    // Param is passed by value, moved
    pub fn set_address(&mut self, v: ::std::vec::Vec<u8>) {
        self.address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_address(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.address
    }

    // Take field
    pub fn take_address(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.address, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for QueryGetAccount {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.address)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.address);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.address.is_empty() {
            os.write_bytes(1, &self.address)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryGetAccount {
        QueryGetAccount::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "address",
                    |m: &QueryGetAccount| { &m.address },
                    |m: &mut QueryGetAccount| { &mut m.address },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<QueryGetAccount>(
                    "QueryGetAccount",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static QueryGetAccount {
        static mut instance: ::protobuf::lazy::Lazy<QueryGetAccount> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const QueryGetAccount,
        };
        unsafe {
            instance.get(QueryGetAccount::new)
        }
    }
}

impl ::protobuf::Clear for QueryGetAccount {
    fn clear(&mut self) {
        self.address.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for QueryGetAccount {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryGetAccount {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct QueryGetAccountResponse {
    // message fields
    pub balance: ::std::vec::Vec<u8>,
    pub nonce: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryGetAccountResponse {
    fn default() -> &'a QueryGetAccountResponse {
        <QueryGetAccountResponse as ::protobuf::Message>::default_instance()
    }
}

impl QueryGetAccountResponse {
    pub fn new() -> QueryGetAccountResponse {
        ::std::default::Default::default()
    }

    // bytes balance = 1;


    pub fn get_balance(&self) -> &[u8] {
        &self.balance
    }
    pub fn clear_balance(&mut self) {
        self.balance.clear();
    }

    // Param is passed by value, moved
    pub fn set_balance(&mut self, v: ::std::vec::Vec<u8>) {
        self.balance = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_balance(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.balance
    }

    // Take field
    pub fn take_balance(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.balance, ::std::vec::Vec::new())
    }

    // uint64 nonce = 2;


    pub fn get_nonce(&self) -> u64 {
        self.nonce
    }
    pub fn clear_nonce(&mut self) {
        self.nonce = 0;
    }

    // Param is passed by value, moved
    pub fn set_nonce(&mut self, v: u64) {
        self.nonce = v;
    }
}

impl ::protobuf::Message for QueryGetAccountResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.balance)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.nonce = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.balance.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.balance);
        }
        if self.nonce != 0 {
            my_size += ::protobuf::rt::value_size(2, self.nonce, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.balance.is_empty() {
            os.write_bytes(1, &self.balance)?;
        }
        if self.nonce != 0 {
            os.write_uint64(2, self.nonce)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryGetAccountResponse {
        QueryGetAccountResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "balance",
                    |m: &QueryGetAccountResponse| { &m.balance },
                    |m: &mut QueryGetAccountResponse| { &mut m.balance },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "nonce",
                    |m: &QueryGetAccountResponse| { &m.nonce },
                    |m: &mut QueryGetAccountResponse| { &mut m.nonce },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<QueryGetAccountResponse>(
                    "QueryGetAccountResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static QueryGetAccountResponse {
        static mut instance: ::protobuf::lazy::Lazy<QueryGetAccountResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const QueryGetAccountResponse,
        };
        unsafe {
            instance.get(QueryGetAccountResponse::new)
        }
    }
}

impl ::protobuf::Clear for QueryGetAccountResponse {
    fn clear(&mut self) {
        self.balance.clear();
        self.nonce = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for QueryGetAccountResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryGetAccountResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct QueryInsertAccount {
    // message fields
    pub address: ::std::vec::Vec<u8>,
    pub balance: ::std::vec::Vec<u8>,
    pub nonce: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryInsertAccount {
    fn default() -> &'a QueryInsertAccount {
        <QueryInsertAccount as ::protobuf::Message>::default_instance()
    }
}

impl QueryInsertAccount {
    pub fn new() -> QueryInsertAccount {
        ::std::default::Default::default()
    }

    // bytes address = 1;


    pub fn get_address(&self) -> &[u8] {
        &self.address
    }
    pub fn clear_address(&mut self) {
        self.address.clear();
    }

    // Param is passed by value, moved
    pub fn set_address(&mut self, v: ::std::vec::Vec<u8>) {
        self.address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_address(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.address
    }

    // Take field
    pub fn take_address(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.address, ::std::vec::Vec::new())
    }

    // bytes balance = 2;


    pub fn get_balance(&self) -> &[u8] {
        &self.balance
    }
    pub fn clear_balance(&mut self) {
        self.balance.clear();
    }

    // Param is passed by value, moved
    pub fn set_balance(&mut self, v: ::std::vec::Vec<u8>) {
        self.balance = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_balance(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.balance
    }

    // Take field
    pub fn take_balance(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.balance, ::std::vec::Vec::new())
    }

    // uint64 nonce = 3;


    pub fn get_nonce(&self) -> u64 {
        self.nonce
    }
    pub fn clear_nonce(&mut self) {
        self.nonce = 0;
    }

    // Param is passed by value, moved
    pub fn set_nonce(&mut self, v: u64) {
        self.nonce = v;
    }
}

impl ::protobuf::Message for QueryInsertAccount {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.address)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.balance)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.nonce = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.address);
        }
        if !self.balance.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.balance);
        }
        if self.nonce != 0 {
            my_size += ::protobuf::rt::value_size(3, self.nonce, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.address.is_empty() {
            os.write_bytes(1, &self.address)?;
        }
        if !self.balance.is_empty() {
            os.write_bytes(2, &self.balance)?;
        }
        if self.nonce != 0 {
            os.write_uint64(3, self.nonce)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryInsertAccount {
        QueryInsertAccount::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "address",
                    |m: &QueryInsertAccount| { &m.address },
                    |m: &mut QueryInsertAccount| { &mut m.address },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "balance",
                    |m: &QueryInsertAccount| { &m.balance },
                    |m: &mut QueryInsertAccount| { &mut m.balance },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "nonce",
                    |m: &QueryInsertAccount| { &m.nonce },
                    |m: &mut QueryInsertAccount| { &mut m.nonce },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<QueryInsertAccount>(
                    "QueryInsertAccount",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static QueryInsertAccount {
        static mut instance: ::protobuf::lazy::Lazy<QueryInsertAccount> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const QueryInsertAccount,
        };
        unsafe {
            instance.get(QueryInsertAccount::new)
        }
    }
}

impl ::protobuf::Clear for QueryInsertAccount {
    fn clear(&mut self) {
        self.address.clear();
        self.balance.clear();
        self.nonce = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for QueryInsertAccount {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryInsertAccount {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct QueryInsertAccountResponse {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryInsertAccountResponse {
    fn default() -> &'a QueryInsertAccountResponse {
        <QueryInsertAccountResponse as ::protobuf::Message>::default_instance()
    }
}

impl QueryInsertAccountResponse {
    pub fn new() -> QueryInsertAccountResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for QueryInsertAccountResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryInsertAccountResponse {
        QueryInsertAccountResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<QueryInsertAccountResponse>(
                    "QueryInsertAccountResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static QueryInsertAccountResponse {
        static mut instance: ::protobuf::lazy::Lazy<QueryInsertAccountResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const QueryInsertAccountResponse,
        };
        unsafe {
            instance.get(QueryInsertAccountResponse::new)
        }
    }
}

impl ::protobuf::Clear for QueryInsertAccountResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for QueryInsertAccountResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryInsertAccountResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct QueryContainsKey {
    // message fields
    pub key: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryContainsKey {
    fn default() -> &'a QueryContainsKey {
        <QueryContainsKey as ::protobuf::Message>::default_instance()
    }
}

impl QueryContainsKey {
    pub fn new() -> QueryContainsKey {
        ::std::default::Default::default()
    }

    // bytes key = 1;


    pub fn get_key(&self) -> &[u8] {
        &self.key
    }
    pub fn clear_key(&mut self) {
        self.key.clear();
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.key
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.key, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for QueryContainsKey {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.key)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.key.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.key);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.key.is_empty() {
            os.write_bytes(1, &self.key)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryContainsKey {
        QueryContainsKey::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "key",
                    |m: &QueryContainsKey| { &m.key },
                    |m: &mut QueryContainsKey| { &mut m.key },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<QueryContainsKey>(
                    "QueryContainsKey",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static QueryContainsKey {
        static mut instance: ::protobuf::lazy::Lazy<QueryContainsKey> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const QueryContainsKey,
        };
        unsafe {
            instance.get(QueryContainsKey::new)
        }
    }
}

impl ::protobuf::Clear for QueryContainsKey {
    fn clear(&mut self) {
        self.key.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for QueryContainsKey {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryContainsKey {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct QueryContainsKeyResponse {
    // message fields
    pub contains: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryContainsKeyResponse {
    fn default() -> &'a QueryContainsKeyResponse {
        <QueryContainsKeyResponse as ::protobuf::Message>::default_instance()
    }
}

impl QueryContainsKeyResponse {
    pub fn new() -> QueryContainsKeyResponse {
        ::std::default::Default::default()
    }

    // bool contains = 1;


    pub fn get_contains(&self) -> bool {
        self.contains
    }
    pub fn clear_contains(&mut self) {
        self.contains = false;
    }

    // Param is passed by value, moved
    pub fn set_contains(&mut self, v: bool) {
        self.contains = v;
    }
}

impl ::protobuf::Message for QueryContainsKeyResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.contains = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.contains != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.contains != false {
            os.write_bool(1, self.contains)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryContainsKeyResponse {
        QueryContainsKeyResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "contains",
                    |m: &QueryContainsKeyResponse| { &m.contains },
                    |m: &mut QueryContainsKeyResponse| { &mut m.contains },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<QueryContainsKeyResponse>(
                    "QueryContainsKeyResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static QueryContainsKeyResponse {
        static mut instance: ::protobuf::lazy::Lazy<QueryContainsKeyResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const QueryContainsKeyResponse,
        };
        unsafe {
            instance.get(QueryContainsKeyResponse::new)
        }
    }
}

impl ::protobuf::Clear for QueryContainsKeyResponse {
    fn clear(&mut self) {
        self.contains = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for QueryContainsKeyResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryContainsKeyResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct QueryGetAccountStorageCell {
    // message fields
    pub address: ::std::vec::Vec<u8>,
    pub index: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryGetAccountStorageCell {
    fn default() -> &'a QueryGetAccountStorageCell {
        <QueryGetAccountStorageCell as ::protobuf::Message>::default_instance()
    }
}

impl QueryGetAccountStorageCell {
    pub fn new() -> QueryGetAccountStorageCell {
        ::std::default::Default::default()
    }

    // bytes address = 1;


    pub fn get_address(&self) -> &[u8] {
        &self.address
    }
    pub fn clear_address(&mut self) {
        self.address.clear();
    }

    // Param is passed by value, moved
    pub fn set_address(&mut self, v: ::std::vec::Vec<u8>) {
        self.address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_address(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.address
    }

    // Take field
    pub fn take_address(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.address, ::std::vec::Vec::new())
    }

    // bytes index = 2;


    pub fn get_index(&self) -> &[u8] {
        &self.index
    }
    pub fn clear_index(&mut self) {
        self.index.clear();
    }

    // Param is passed by value, moved
    pub fn set_index(&mut self, v: ::std::vec::Vec<u8>) {
        self.index = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_index(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.index
    }

    // Take field
    pub fn take_index(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.index, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for QueryGetAccountStorageCell {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.address)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.index)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.address);
        }
        if !self.index.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.index);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.address.is_empty() {
            os.write_bytes(1, &self.address)?;
        }
        if !self.index.is_empty() {
            os.write_bytes(2, &self.index)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryGetAccountStorageCell {
        QueryGetAccountStorageCell::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "address",
                    |m: &QueryGetAccountStorageCell| { &m.address },
                    |m: &mut QueryGetAccountStorageCell| { &mut m.address },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "index",
                    |m: &QueryGetAccountStorageCell| { &m.index },
                    |m: &mut QueryGetAccountStorageCell| { &mut m.index },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<QueryGetAccountStorageCell>(
                    "QueryGetAccountStorageCell",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static QueryGetAccountStorageCell {
        static mut instance: ::protobuf::lazy::Lazy<QueryGetAccountStorageCell> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const QueryGetAccountStorageCell,
        };
        unsafe {
            instance.get(QueryGetAccountStorageCell::new)
        }
    }
}

impl ::protobuf::Clear for QueryGetAccountStorageCell {
    fn clear(&mut self) {
        self.address.clear();
        self.index.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for QueryGetAccountStorageCell {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryGetAccountStorageCell {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct QueryGetAccountStorageCellResponse {
    // message fields
    pub value: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryGetAccountStorageCellResponse {
    fn default() -> &'a QueryGetAccountStorageCellResponse {
        <QueryGetAccountStorageCellResponse as ::protobuf::Message>::default_instance()
    }
}

impl QueryGetAccountStorageCellResponse {
    pub fn new() -> QueryGetAccountStorageCellResponse {
        ::std::default::Default::default()
    }

    // bytes value = 1;


    pub fn get_value(&self) -> &[u8] {
        &self.value
    }
    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::vec::Vec<u8>) {
        self.value = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.value
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.value, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for QueryGetAccountStorageCellResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.value)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.value.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.value);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.value.is_empty() {
            os.write_bytes(1, &self.value)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryGetAccountStorageCellResponse {
        QueryGetAccountStorageCellResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "value",
                    |m: &QueryGetAccountStorageCellResponse| { &m.value },
                    |m: &mut QueryGetAccountStorageCellResponse| { &mut m.value },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<QueryGetAccountStorageCellResponse>(
                    "QueryGetAccountStorageCellResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static QueryGetAccountStorageCellResponse {
        static mut instance: ::protobuf::lazy::Lazy<QueryGetAccountStorageCellResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const QueryGetAccountStorageCellResponse,
        };
        unsafe {
            instance.get(QueryGetAccountStorageCellResponse::new)
        }
    }
}

impl ::protobuf::Clear for QueryGetAccountStorageCellResponse {
    fn clear(&mut self) {
        self.value.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for QueryGetAccountStorageCellResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryGetAccountStorageCellResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct QueryGetAccountCode {
    // message fields
    pub address: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryGetAccountCode {
    fn default() -> &'a QueryGetAccountCode {
        <QueryGetAccountCode as ::protobuf::Message>::default_instance()
    }
}

impl QueryGetAccountCode {
    pub fn new() -> QueryGetAccountCode {
        ::std::default::Default::default()
    }

    // bytes address = 1;


    pub fn get_address(&self) -> &[u8] {
        &self.address
    }
    pub fn clear_address(&mut self) {
        self.address.clear();
    }

    // Param is passed by value, moved
    pub fn set_address(&mut self, v: ::std::vec::Vec<u8>) {
        self.address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_address(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.address
    }

    // Take field
    pub fn take_address(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.address, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for QueryGetAccountCode {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.address)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.address);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.address.is_empty() {
            os.write_bytes(1, &self.address)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryGetAccountCode {
        QueryGetAccountCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "address",
                    |m: &QueryGetAccountCode| { &m.address },
                    |m: &mut QueryGetAccountCode| { &mut m.address },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<QueryGetAccountCode>(
                    "QueryGetAccountCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static QueryGetAccountCode {
        static mut instance: ::protobuf::lazy::Lazy<QueryGetAccountCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const QueryGetAccountCode,
        };
        unsafe {
            instance.get(QueryGetAccountCode::new)
        }
    }
}

impl ::protobuf::Clear for QueryGetAccountCode {
    fn clear(&mut self) {
        self.address.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for QueryGetAccountCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryGetAccountCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct QueryGetAccountCodeResponse {
    // message fields
    pub code: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryGetAccountCodeResponse {
    fn default() -> &'a QueryGetAccountCodeResponse {
        <QueryGetAccountCodeResponse as ::protobuf::Message>::default_instance()
    }
}

impl QueryGetAccountCodeResponse {
    pub fn new() -> QueryGetAccountCodeResponse {
        ::std::default::Default::default()
    }

    // bytes code = 1;


    pub fn get_code(&self) -> &[u8] {
        &self.code
    }
    pub fn clear_code(&mut self) {
        self.code.clear();
    }

    // Param is passed by value, moved
    pub fn set_code(&mut self, v: ::std::vec::Vec<u8>) {
        self.code = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_code(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.code
    }

    // Take field
    pub fn take_code(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.code, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for QueryGetAccountCodeResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.code)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.code.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.code);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.code.is_empty() {
            os.write_bytes(1, &self.code)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryGetAccountCodeResponse {
        QueryGetAccountCodeResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "code",
                    |m: &QueryGetAccountCodeResponse| { &m.code },
                    |m: &mut QueryGetAccountCodeResponse| { &mut m.code },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<QueryGetAccountCodeResponse>(
                    "QueryGetAccountCodeResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static QueryGetAccountCodeResponse {
        static mut instance: ::protobuf::lazy::Lazy<QueryGetAccountCodeResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const QueryGetAccountCodeResponse,
        };
        unsafe {
            instance.get(QueryGetAccountCodeResponse::new)
        }
    }
}

impl ::protobuf::Clear for QueryGetAccountCodeResponse {
    fn clear(&mut self) {
        self.code.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for QueryGetAccountCodeResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryGetAccountCodeResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct QueryInsertAccountCode {
    // message fields
    pub address: ::std::vec::Vec<u8>,
    pub code: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryInsertAccountCode {
    fn default() -> &'a QueryInsertAccountCode {
        <QueryInsertAccountCode as ::protobuf::Message>::default_instance()
    }
}

impl QueryInsertAccountCode {
    pub fn new() -> QueryInsertAccountCode {
        ::std::default::Default::default()
    }

    // bytes address = 1;


    pub fn get_address(&self) -> &[u8] {
        &self.address
    }
    pub fn clear_address(&mut self) {
        self.address.clear();
    }

    // Param is passed by value, moved
    pub fn set_address(&mut self, v: ::std::vec::Vec<u8>) {
        self.address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_address(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.address
    }

    // Take field
    pub fn take_address(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.address, ::std::vec::Vec::new())
    }

    // bytes code = 2;


    pub fn get_code(&self) -> &[u8] {
        &self.code
    }
    pub fn clear_code(&mut self) {
        self.code.clear();
    }

    // Param is passed by value, moved
    pub fn set_code(&mut self, v: ::std::vec::Vec<u8>) {
        self.code = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_code(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.code
    }

    // Take field
    pub fn take_code(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.code, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for QueryInsertAccountCode {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.address)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.code)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.address);
        }
        if !self.code.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.code);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.address.is_empty() {
            os.write_bytes(1, &self.address)?;
        }
        if !self.code.is_empty() {
            os.write_bytes(2, &self.code)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryInsertAccountCode {
        QueryInsertAccountCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "address",
                    |m: &QueryInsertAccountCode| { &m.address },
                    |m: &mut QueryInsertAccountCode| { &mut m.address },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "code",
                    |m: &QueryInsertAccountCode| { &m.code },
                    |m: &mut QueryInsertAccountCode| { &mut m.code },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<QueryInsertAccountCode>(
                    "QueryInsertAccountCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static QueryInsertAccountCode {
        static mut instance: ::protobuf::lazy::Lazy<QueryInsertAccountCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const QueryInsertAccountCode,
        };
        unsafe {
            instance.get(QueryInsertAccountCode::new)
        }
    }
}

impl ::protobuf::Clear for QueryInsertAccountCode {
    fn clear(&mut self) {
        self.address.clear();
        self.code.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for QueryInsertAccountCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryInsertAccountCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct QueryInsertAccountCodeResponse {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryInsertAccountCodeResponse {
    fn default() -> &'a QueryInsertAccountCodeResponse {
        <QueryInsertAccountCodeResponse as ::protobuf::Message>::default_instance()
    }
}

impl QueryInsertAccountCodeResponse {
    pub fn new() -> QueryInsertAccountCodeResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for QueryInsertAccountCodeResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryInsertAccountCodeResponse {
        QueryInsertAccountCodeResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<QueryInsertAccountCodeResponse>(
                    "QueryInsertAccountCodeResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static QueryInsertAccountCodeResponse {
        static mut instance: ::protobuf::lazy::Lazy<QueryInsertAccountCodeResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const QueryInsertAccountCodeResponse,
        };
        unsafe {
            instance.get(QueryInsertAccountCodeResponse::new)
        }
    }
}

impl ::protobuf::Clear for QueryInsertAccountCodeResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for QueryInsertAccountCodeResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryInsertAccountCodeResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct QueryInsertStorageCell {
    // message fields
    pub address: ::std::vec::Vec<u8>,
    pub index: ::std::vec::Vec<u8>,
    pub value: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryInsertStorageCell {
    fn default() -> &'a QueryInsertStorageCell {
        <QueryInsertStorageCell as ::protobuf::Message>::default_instance()
    }
}

impl QueryInsertStorageCell {
    pub fn new() -> QueryInsertStorageCell {
        ::std::default::Default::default()
    }

    // bytes address = 1;


    pub fn get_address(&self) -> &[u8] {
        &self.address
    }
    pub fn clear_address(&mut self) {
        self.address.clear();
    }

    // Param is passed by value, moved
    pub fn set_address(&mut self, v: ::std::vec::Vec<u8>) {
        self.address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_address(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.address
    }

    // Take field
    pub fn take_address(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.address, ::std::vec::Vec::new())
    }

    // bytes index = 2;


    pub fn get_index(&self) -> &[u8] {
        &self.index
    }
    pub fn clear_index(&mut self) {
        self.index.clear();
    }

    // Param is passed by value, moved
    pub fn set_index(&mut self, v: ::std::vec::Vec<u8>) {
        self.index = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_index(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.index
    }

    // Take field
    pub fn take_index(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.index, ::std::vec::Vec::new())
    }

    // bytes value = 3;


    pub fn get_value(&self) -> &[u8] {
        &self.value
    }
    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::vec::Vec<u8>) {
        self.value = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.value
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.value, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for QueryInsertStorageCell {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.address)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.index)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.value)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.address);
        }
        if !self.index.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.index);
        }
        if !self.value.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.value);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.address.is_empty() {
            os.write_bytes(1, &self.address)?;
        }
        if !self.index.is_empty() {
            os.write_bytes(2, &self.index)?;
        }
        if !self.value.is_empty() {
            os.write_bytes(3, &self.value)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryInsertStorageCell {
        QueryInsertStorageCell::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "address",
                    |m: &QueryInsertStorageCell| { &m.address },
                    |m: &mut QueryInsertStorageCell| { &mut m.address },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "index",
                    |m: &QueryInsertStorageCell| { &m.index },
                    |m: &mut QueryInsertStorageCell| { &mut m.index },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "value",
                    |m: &QueryInsertStorageCell| { &m.value },
                    |m: &mut QueryInsertStorageCell| { &mut m.value },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<QueryInsertStorageCell>(
                    "QueryInsertStorageCell",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static QueryInsertStorageCell {
        static mut instance: ::protobuf::lazy::Lazy<QueryInsertStorageCell> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const QueryInsertStorageCell,
        };
        unsafe {
            instance.get(QueryInsertStorageCell::new)
        }
    }
}

impl ::protobuf::Clear for QueryInsertStorageCell {
    fn clear(&mut self) {
        self.address.clear();
        self.index.clear();
        self.value.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for QueryInsertStorageCell {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryInsertStorageCell {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct QueryInsertStorageCellResponse {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryInsertStorageCellResponse {
    fn default() -> &'a QueryInsertStorageCellResponse {
        <QueryInsertStorageCellResponse as ::protobuf::Message>::default_instance()
    }
}

impl QueryInsertStorageCellResponse {
    pub fn new() -> QueryInsertStorageCellResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for QueryInsertStorageCellResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryInsertStorageCellResponse {
        QueryInsertStorageCellResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<QueryInsertStorageCellResponse>(
                    "QueryInsertStorageCellResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static QueryInsertStorageCellResponse {
        static mut instance: ::protobuf::lazy::Lazy<QueryInsertStorageCellResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const QueryInsertStorageCellResponse,
        };
        unsafe {
            instance.get(QueryInsertStorageCellResponse::new)
        }
    }
}

impl ::protobuf::Clear for QueryInsertStorageCellResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for QueryInsertStorageCellResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryInsertStorageCellResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct QueryRemove {
    // message fields
    pub address: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryRemove {
    fn default() -> &'a QueryRemove {
        <QueryRemove as ::protobuf::Message>::default_instance()
    }
}

impl QueryRemove {
    pub fn new() -> QueryRemove {
        ::std::default::Default::default()
    }

    // bytes address = 1;


    pub fn get_address(&self) -> &[u8] {
        &self.address
    }
    pub fn clear_address(&mut self) {
        self.address.clear();
    }

    // Param is passed by value, moved
    pub fn set_address(&mut self, v: ::std::vec::Vec<u8>) {
        self.address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_address(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.address
    }

    // Take field
    pub fn take_address(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.address, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for QueryRemove {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.address)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.address);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.address.is_empty() {
            os.write_bytes(1, &self.address)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryRemove {
        QueryRemove::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "address",
                    |m: &QueryRemove| { &m.address },
                    |m: &mut QueryRemove| { &mut m.address },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<QueryRemove>(
                    "QueryRemove",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static QueryRemove {
        static mut instance: ::protobuf::lazy::Lazy<QueryRemove> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const QueryRemove,
        };
        unsafe {
            instance.get(QueryRemove::new)
        }
    }
}

impl ::protobuf::Clear for QueryRemove {
    fn clear(&mut self) {
        self.address.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for QueryRemove {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryRemove {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct QueryRemoveResponse {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryRemoveResponse {
    fn default() -> &'a QueryRemoveResponse {
        <QueryRemoveResponse as ::protobuf::Message>::default_instance()
    }
}

impl QueryRemoveResponse {
    pub fn new() -> QueryRemoveResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for QueryRemoveResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryRemoveResponse {
        QueryRemoveResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<QueryRemoveResponse>(
                    "QueryRemoveResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static QueryRemoveResponse {
        static mut instance: ::protobuf::lazy::Lazy<QueryRemoveResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const QueryRemoveResponse,
        };
        unsafe {
            instance.get(QueryRemoveResponse::new)
        }
    }
}

impl ::protobuf::Clear for QueryRemoveResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for QueryRemoveResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryRemoveResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct QueryRemoveStorageCell {
    // message fields
    pub address: ::std::vec::Vec<u8>,
    pub index: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryRemoveStorageCell {
    fn default() -> &'a QueryRemoveStorageCell {
        <QueryRemoveStorageCell as ::protobuf::Message>::default_instance()
    }
}

impl QueryRemoveStorageCell {
    pub fn new() -> QueryRemoveStorageCell {
        ::std::default::Default::default()
    }

    // bytes address = 1;


    pub fn get_address(&self) -> &[u8] {
        &self.address
    }
    pub fn clear_address(&mut self) {
        self.address.clear();
    }

    // Param is passed by value, moved
    pub fn set_address(&mut self, v: ::std::vec::Vec<u8>) {
        self.address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_address(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.address
    }

    // Take field
    pub fn take_address(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.address, ::std::vec::Vec::new())
    }

    // bytes index = 2;


    pub fn get_index(&self) -> &[u8] {
        &self.index
    }
    pub fn clear_index(&mut self) {
        self.index.clear();
    }

    // Param is passed by value, moved
    pub fn set_index(&mut self, v: ::std::vec::Vec<u8>) {
        self.index = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_index(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.index
    }

    // Take field
    pub fn take_index(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.index, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for QueryRemoveStorageCell {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.address)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.index)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.address);
        }
        if !self.index.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.index);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.address.is_empty() {
            os.write_bytes(1, &self.address)?;
        }
        if !self.index.is_empty() {
            os.write_bytes(2, &self.index)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryRemoveStorageCell {
        QueryRemoveStorageCell::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "address",
                    |m: &QueryRemoveStorageCell| { &m.address },
                    |m: &mut QueryRemoveStorageCell| { &mut m.address },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "index",
                    |m: &QueryRemoveStorageCell| { &m.index },
                    |m: &mut QueryRemoveStorageCell| { &mut m.index },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<QueryRemoveStorageCell>(
                    "QueryRemoveStorageCell",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static QueryRemoveStorageCell {
        static mut instance: ::protobuf::lazy::Lazy<QueryRemoveStorageCell> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const QueryRemoveStorageCell,
        };
        unsafe {
            instance.get(QueryRemoveStorageCell::new)
        }
    }
}

impl ::protobuf::Clear for QueryRemoveStorageCell {
    fn clear(&mut self) {
        self.address.clear();
        self.index.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for QueryRemoveStorageCell {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryRemoveStorageCell {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct QueryRemoveStorageCellResponse {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryRemoveStorageCellResponse {
    fn default() -> &'a QueryRemoveStorageCellResponse {
        <QueryRemoveStorageCellResponse as ::protobuf::Message>::default_instance()
    }
}

impl QueryRemoveStorageCellResponse {
    pub fn new() -> QueryRemoveStorageCellResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for QueryRemoveStorageCellResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryRemoveStorageCellResponse {
        QueryRemoveStorageCellResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<QueryRemoveStorageCellResponse>(
                    "QueryRemoveStorageCellResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static QueryRemoveStorageCellResponse {
        static mut instance: ::protobuf::lazy::Lazy<QueryRemoveStorageCellResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const QueryRemoveStorageCellResponse,
        };
        unsafe {
            instance.get(QueryRemoveStorageCellResponse::new)
        }
    }
}

impl ::protobuf::Clear for QueryRemoveStorageCellResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for QueryRemoveStorageCellResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryRemoveStorageCellResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct QueryRemoveStorage {
    // message fields
    pub address: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryRemoveStorage {
    fn default() -> &'a QueryRemoveStorage {
        <QueryRemoveStorage as ::protobuf::Message>::default_instance()
    }
}

impl QueryRemoveStorage {
    pub fn new() -> QueryRemoveStorage {
        ::std::default::Default::default()
    }

    // bytes address = 1;


    pub fn get_address(&self) -> &[u8] {
        &self.address
    }
    pub fn clear_address(&mut self) {
        self.address.clear();
    }

    // Param is passed by value, moved
    pub fn set_address(&mut self, v: ::std::vec::Vec<u8>) {
        self.address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_address(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.address
    }

    // Take field
    pub fn take_address(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.address, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for QueryRemoveStorage {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.address)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.address);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.address.is_empty() {
            os.write_bytes(1, &self.address)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryRemoveStorage {
        QueryRemoveStorage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "address",
                    |m: &QueryRemoveStorage| { &m.address },
                    |m: &mut QueryRemoveStorage| { &mut m.address },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<QueryRemoveStorage>(
                    "QueryRemoveStorage",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static QueryRemoveStorage {
        static mut instance: ::protobuf::lazy::Lazy<QueryRemoveStorage> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const QueryRemoveStorage,
        };
        unsafe {
            instance.get(QueryRemoveStorage::new)
        }
    }
}

impl ::protobuf::Clear for QueryRemoveStorage {
    fn clear(&mut self) {
        self.address.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for QueryRemoveStorage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryRemoveStorage {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct QueryRemoveStorageResponse {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryRemoveStorageResponse {
    fn default() -> &'a QueryRemoveStorageResponse {
        <QueryRemoveStorageResponse as ::protobuf::Message>::default_instance()
    }
}

impl QueryRemoveStorageResponse {
    pub fn new() -> QueryRemoveStorageResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for QueryRemoveStorageResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryRemoveStorageResponse {
        QueryRemoveStorageResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<QueryRemoveStorageResponse>(
                    "QueryRemoveStorageResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static QueryRemoveStorageResponse {
        static mut instance: ::protobuf::lazy::Lazy<QueryRemoveStorageResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const QueryRemoveStorageResponse,
        };
        unsafe {
            instance.get(QueryRemoveStorageResponse::new)
        }
    }
}

impl ::protobuf::Clear for QueryRemoveStorageResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for QueryRemoveStorageResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryRemoveStorageResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct QueryBlockHash {
    // message fields
    pub number: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryBlockHash {
    fn default() -> &'a QueryBlockHash {
        <QueryBlockHash as ::protobuf::Message>::default_instance()
    }
}

impl QueryBlockHash {
    pub fn new() -> QueryBlockHash {
        ::std::default::Default::default()
    }

    // bytes number = 1;


    pub fn get_number(&self) -> &[u8] {
        &self.number
    }
    pub fn clear_number(&mut self) {
        self.number.clear();
    }

    // Param is passed by value, moved
    pub fn set_number(&mut self, v: ::std::vec::Vec<u8>) {
        self.number = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_number(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.number
    }

    // Take field
    pub fn take_number(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.number, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for QueryBlockHash {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.number)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.number.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.number);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.number.is_empty() {
            os.write_bytes(1, &self.number)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryBlockHash {
        QueryBlockHash::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "number",
                    |m: &QueryBlockHash| { &m.number },
                    |m: &mut QueryBlockHash| { &mut m.number },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<QueryBlockHash>(
                    "QueryBlockHash",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static QueryBlockHash {
        static mut instance: ::protobuf::lazy::Lazy<QueryBlockHash> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const QueryBlockHash,
        };
        unsafe {
            instance.get(QueryBlockHash::new)
        }
    }
}

impl ::protobuf::Clear for QueryBlockHash {
    fn clear(&mut self) {
        self.number.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for QueryBlockHash {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryBlockHash {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct QueryBlockHashResponse {
    // message fields
    pub hash: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryBlockHashResponse {
    fn default() -> &'a QueryBlockHashResponse {
        <QueryBlockHashResponse as ::protobuf::Message>::default_instance()
    }
}

impl QueryBlockHashResponse {
    pub fn new() -> QueryBlockHashResponse {
        ::std::default::Default::default()
    }

    // bytes hash = 1;


    pub fn get_hash(&self) -> &[u8] {
        &self.hash
    }
    pub fn clear_hash(&mut self) {
        self.hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_hash(&mut self, v: ::std::vec::Vec<u8>) {
        self.hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hash(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.hash
    }

    // Take field
    pub fn take_hash(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.hash, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for QueryBlockHashResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.hash)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.hash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.hash);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.hash.is_empty() {
            os.write_bytes(1, &self.hash)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryBlockHashResponse {
        QueryBlockHashResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "hash",
                    |m: &QueryBlockHashResponse| { &m.hash },
                    |m: &mut QueryBlockHashResponse| { &mut m.hash },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<QueryBlockHashResponse>(
                    "QueryBlockHashResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static QueryBlockHashResponse {
        static mut instance: ::protobuf::lazy::Lazy<QueryBlockHashResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const QueryBlockHashResponse,
        };
        unsafe {
            instance.get(QueryBlockHashResponse::new)
        }
    }
}

impl ::protobuf::Clear for QueryBlockHashResponse {
    fn clear(&mut self) {
        self.hash.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for QueryBlockHashResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryBlockHashResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct QueryAddVerificationDetails {
    // message fields
    pub userAddress: ::std::vec::Vec<u8>,
    pub issuerAddress: ::std::vec::Vec<u8>,
    pub originChain: ::std::string::String,
    pub verificationType: u32,
    pub issuanceTimestamp: u32,
    pub expirationTimestamp: u32,
    pub proofData: ::std::vec::Vec<u8>,
    pub schema: ::std::string::String,
    pub issuerVerificationId: ::std::string::String,
    pub version: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryAddVerificationDetails {
    fn default() -> &'a QueryAddVerificationDetails {
        <QueryAddVerificationDetails as ::protobuf::Message>::default_instance()
    }
}

impl QueryAddVerificationDetails {
    pub fn new() -> QueryAddVerificationDetails {
        ::std::default::Default::default()
    }

    // bytes userAddress = 1;


    pub fn get_userAddress(&self) -> &[u8] {
        &self.userAddress
    }
    pub fn clear_userAddress(&mut self) {
        self.userAddress.clear();
    }

    // Param is passed by value, moved
    pub fn set_userAddress(&mut self, v: ::std::vec::Vec<u8>) {
        self.userAddress = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_userAddress(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.userAddress
    }

    // Take field
    pub fn take_userAddress(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.userAddress, ::std::vec::Vec::new())
    }

    // bytes issuerAddress = 2;


    pub fn get_issuerAddress(&self) -> &[u8] {
        &self.issuerAddress
    }
    pub fn clear_issuerAddress(&mut self) {
        self.issuerAddress.clear();
    }

    // Param is passed by value, moved
    pub fn set_issuerAddress(&mut self, v: ::std::vec::Vec<u8>) {
        self.issuerAddress = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_issuerAddress(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.issuerAddress
    }

    // Take field
    pub fn take_issuerAddress(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.issuerAddress, ::std::vec::Vec::new())
    }

    // string originChain = 3;


    pub fn get_originChain(&self) -> &str {
        &self.originChain
    }
    pub fn clear_originChain(&mut self) {
        self.originChain.clear();
    }

    // Param is passed by value, moved
    pub fn set_originChain(&mut self, v: ::std::string::String) {
        self.originChain = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_originChain(&mut self) -> &mut ::std::string::String {
        &mut self.originChain
    }

    // Take field
    pub fn take_originChain(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.originChain, ::std::string::String::new())
    }

    // uint32 verificationType = 4;


    pub fn get_verificationType(&self) -> u32 {
        self.verificationType
    }
    pub fn clear_verificationType(&mut self) {
        self.verificationType = 0;
    }

    // Param is passed by value, moved
    pub fn set_verificationType(&mut self, v: u32) {
        self.verificationType = v;
    }

    // uint32 issuanceTimestamp = 5;


    pub fn get_issuanceTimestamp(&self) -> u32 {
        self.issuanceTimestamp
    }
    pub fn clear_issuanceTimestamp(&mut self) {
        self.issuanceTimestamp = 0;
    }

    // Param is passed by value, moved
    pub fn set_issuanceTimestamp(&mut self, v: u32) {
        self.issuanceTimestamp = v;
    }

    // uint32 expirationTimestamp = 6;


    pub fn get_expirationTimestamp(&self) -> u32 {
        self.expirationTimestamp
    }
    pub fn clear_expirationTimestamp(&mut self) {
        self.expirationTimestamp = 0;
    }

    // Param is passed by value, moved
    pub fn set_expirationTimestamp(&mut self, v: u32) {
        self.expirationTimestamp = v;
    }

    // bytes proofData = 7;


    pub fn get_proofData(&self) -> &[u8] {
        &self.proofData
    }
    pub fn clear_proofData(&mut self) {
        self.proofData.clear();
    }

    // Param is passed by value, moved
    pub fn set_proofData(&mut self, v: ::std::vec::Vec<u8>) {
        self.proofData = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_proofData(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.proofData
    }

    // Take field
    pub fn take_proofData(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.proofData, ::std::vec::Vec::new())
    }

    // string schema = 8;


    pub fn get_schema(&self) -> &str {
        &self.schema
    }
    pub fn clear_schema(&mut self) {
        self.schema.clear();
    }

    // Param is passed by value, moved
    pub fn set_schema(&mut self, v: ::std::string::String) {
        self.schema = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_schema(&mut self) -> &mut ::std::string::String {
        &mut self.schema
    }

    // Take field
    pub fn take_schema(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.schema, ::std::string::String::new())
    }

    // string issuerVerificationId = 9;


    pub fn get_issuerVerificationId(&self) -> &str {
        &self.issuerVerificationId
    }
    pub fn clear_issuerVerificationId(&mut self) {
        self.issuerVerificationId.clear();
    }

    // Param is passed by value, moved
    pub fn set_issuerVerificationId(&mut self, v: ::std::string::String) {
        self.issuerVerificationId = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_issuerVerificationId(&mut self) -> &mut ::std::string::String {
        &mut self.issuerVerificationId
    }

    // Take field
    pub fn take_issuerVerificationId(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.issuerVerificationId, ::std::string::String::new())
    }

    // uint32 version = 10;


    pub fn get_version(&self) -> u32 {
        self.version
    }
    pub fn clear_version(&mut self) {
        self.version = 0;
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: u32) {
        self.version = v;
    }
}

impl ::protobuf::Message for QueryAddVerificationDetails {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.userAddress)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.issuerAddress)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.originChain)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.verificationType = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.issuanceTimestamp = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.expirationTimestamp = tmp;
                },
                7 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.proofData)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.schema)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.issuerVerificationId)?;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.version = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.userAddress.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.userAddress);
        }
        if !self.issuerAddress.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.issuerAddress);
        }
        if !self.originChain.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.originChain);
        }
        if self.verificationType != 0 {
            my_size += ::protobuf::rt::value_size(4, self.verificationType, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.issuanceTimestamp != 0 {
            my_size += ::protobuf::rt::value_size(5, self.issuanceTimestamp, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.expirationTimestamp != 0 {
            my_size += ::protobuf::rt::value_size(6, self.expirationTimestamp, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.proofData.is_empty() {
            my_size += ::protobuf::rt::bytes_size(7, &self.proofData);
        }
        if !self.schema.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.schema);
        }
        if !self.issuerVerificationId.is_empty() {
            my_size += ::protobuf::rt::string_size(9, &self.issuerVerificationId);
        }
        if self.version != 0 {
            my_size += ::protobuf::rt::value_size(10, self.version, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.userAddress.is_empty() {
            os.write_bytes(1, &self.userAddress)?;
        }
        if !self.issuerAddress.is_empty() {
            os.write_bytes(2, &self.issuerAddress)?;
        }
        if !self.originChain.is_empty() {
            os.write_string(3, &self.originChain)?;
        }
        if self.verificationType != 0 {
            os.write_uint32(4, self.verificationType)?;
        }
        if self.issuanceTimestamp != 0 {
            os.write_uint32(5, self.issuanceTimestamp)?;
        }
        if self.expirationTimestamp != 0 {
            os.write_uint32(6, self.expirationTimestamp)?;
        }
        if !self.proofData.is_empty() {
            os.write_bytes(7, &self.proofData)?;
        }
        if !self.schema.is_empty() {
            os.write_string(8, &self.schema)?;
        }
        if !self.issuerVerificationId.is_empty() {
            os.write_string(9, &self.issuerVerificationId)?;
        }
        if self.version != 0 {
            os.write_uint32(10, self.version)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryAddVerificationDetails {
        QueryAddVerificationDetails::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "userAddress",
                    |m: &QueryAddVerificationDetails| { &m.userAddress },
                    |m: &mut QueryAddVerificationDetails| { &mut m.userAddress },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "issuerAddress",
                    |m: &QueryAddVerificationDetails| { &m.issuerAddress },
                    |m: &mut QueryAddVerificationDetails| { &mut m.issuerAddress },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "originChain",
                    |m: &QueryAddVerificationDetails| { &m.originChain },
                    |m: &mut QueryAddVerificationDetails| { &mut m.originChain },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "verificationType",
                    |m: &QueryAddVerificationDetails| { &m.verificationType },
                    |m: &mut QueryAddVerificationDetails| { &mut m.verificationType },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "issuanceTimestamp",
                    |m: &QueryAddVerificationDetails| { &m.issuanceTimestamp },
                    |m: &mut QueryAddVerificationDetails| { &mut m.issuanceTimestamp },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "expirationTimestamp",
                    |m: &QueryAddVerificationDetails| { &m.expirationTimestamp },
                    |m: &mut QueryAddVerificationDetails| { &mut m.expirationTimestamp },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "proofData",
                    |m: &QueryAddVerificationDetails| { &m.proofData },
                    |m: &mut QueryAddVerificationDetails| { &mut m.proofData },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "schema",
                    |m: &QueryAddVerificationDetails| { &m.schema },
                    |m: &mut QueryAddVerificationDetails| { &mut m.schema },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "issuerVerificationId",
                    |m: &QueryAddVerificationDetails| { &m.issuerVerificationId },
                    |m: &mut QueryAddVerificationDetails| { &mut m.issuerVerificationId },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "version",
                    |m: &QueryAddVerificationDetails| { &m.version },
                    |m: &mut QueryAddVerificationDetails| { &mut m.version },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<QueryAddVerificationDetails>(
                    "QueryAddVerificationDetails",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static QueryAddVerificationDetails {
        static mut instance: ::protobuf::lazy::Lazy<QueryAddVerificationDetails> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const QueryAddVerificationDetails,
        };
        unsafe {
            instance.get(QueryAddVerificationDetails::new)
        }
    }
}

impl ::protobuf::Clear for QueryAddVerificationDetails {
    fn clear(&mut self) {
        self.userAddress.clear();
        self.issuerAddress.clear();
        self.originChain.clear();
        self.verificationType = 0;
        self.issuanceTimestamp = 0;
        self.expirationTimestamp = 0;
        self.proofData.clear();
        self.schema.clear();
        self.issuerVerificationId.clear();
        self.version = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for QueryAddVerificationDetails {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryAddVerificationDetails {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct QueryAddVerificationDetailsResponse {
    // message fields
    pub verificationId: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryAddVerificationDetailsResponse {
    fn default() -> &'a QueryAddVerificationDetailsResponse {
        <QueryAddVerificationDetailsResponse as ::protobuf::Message>::default_instance()
    }
}

impl QueryAddVerificationDetailsResponse {
    pub fn new() -> QueryAddVerificationDetailsResponse {
        ::std::default::Default::default()
    }

    // bytes verificationId = 1;


    pub fn get_verificationId(&self) -> &[u8] {
        &self.verificationId
    }
    pub fn clear_verificationId(&mut self) {
        self.verificationId.clear();
    }

    // Param is passed by value, moved
    pub fn set_verificationId(&mut self, v: ::std::vec::Vec<u8>) {
        self.verificationId = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_verificationId(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.verificationId
    }

    // Take field
    pub fn take_verificationId(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.verificationId, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for QueryAddVerificationDetailsResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.verificationId)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.verificationId.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.verificationId);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.verificationId.is_empty() {
            os.write_bytes(1, &self.verificationId)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryAddVerificationDetailsResponse {
        QueryAddVerificationDetailsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "verificationId",
                    |m: &QueryAddVerificationDetailsResponse| { &m.verificationId },
                    |m: &mut QueryAddVerificationDetailsResponse| { &mut m.verificationId },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<QueryAddVerificationDetailsResponse>(
                    "QueryAddVerificationDetailsResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static QueryAddVerificationDetailsResponse {
        static mut instance: ::protobuf::lazy::Lazy<QueryAddVerificationDetailsResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const QueryAddVerificationDetailsResponse,
        };
        unsafe {
            instance.get(QueryAddVerificationDetailsResponse::new)
        }
    }
}

impl ::protobuf::Clear for QueryAddVerificationDetailsResponse {
    fn clear(&mut self) {
        self.verificationId.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for QueryAddVerificationDetailsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryAddVerificationDetailsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct QueryHasVerification {
    // message fields
    pub userAddress: ::std::vec::Vec<u8>,
    pub verificationType: u32,
    pub expirationTimestamp: u32,
    pub allowedIssuers: ::protobuf::RepeatedField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryHasVerification {
    fn default() -> &'a QueryHasVerification {
        <QueryHasVerification as ::protobuf::Message>::default_instance()
    }
}

impl QueryHasVerification {
    pub fn new() -> QueryHasVerification {
        ::std::default::Default::default()
    }

    // bytes userAddress = 1;


    pub fn get_userAddress(&self) -> &[u8] {
        &self.userAddress
    }
    pub fn clear_userAddress(&mut self) {
        self.userAddress.clear();
    }

    // Param is passed by value, moved
    pub fn set_userAddress(&mut self, v: ::std::vec::Vec<u8>) {
        self.userAddress = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_userAddress(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.userAddress
    }

    // Take field
    pub fn take_userAddress(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.userAddress, ::std::vec::Vec::new())
    }

    // uint32 verificationType = 2;


    pub fn get_verificationType(&self) -> u32 {
        self.verificationType
    }
    pub fn clear_verificationType(&mut self) {
        self.verificationType = 0;
    }

    // Param is passed by value, moved
    pub fn set_verificationType(&mut self, v: u32) {
        self.verificationType = v;
    }

    // uint32 expirationTimestamp = 3;


    pub fn get_expirationTimestamp(&self) -> u32 {
        self.expirationTimestamp
    }
    pub fn clear_expirationTimestamp(&mut self) {
        self.expirationTimestamp = 0;
    }

    // Param is passed by value, moved
    pub fn set_expirationTimestamp(&mut self, v: u32) {
        self.expirationTimestamp = v;
    }

    // repeated bytes allowedIssuers = 4;


    pub fn get_allowedIssuers(&self) -> &[::std::vec::Vec<u8>] {
        &self.allowedIssuers
    }
    pub fn clear_allowedIssuers(&mut self) {
        self.allowedIssuers.clear();
    }

    // Param is passed by value, moved
    pub fn set_allowedIssuers(&mut self, v: ::protobuf::RepeatedField<::std::vec::Vec<u8>>) {
        self.allowedIssuers = v;
    }

    // Mutable pointer to the field.
    pub fn mut_allowedIssuers(&mut self) -> &mut ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        &mut self.allowedIssuers
    }

    // Take field
    pub fn take_allowedIssuers(&mut self) -> ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        ::std::mem::replace(&mut self.allowedIssuers, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for QueryHasVerification {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.userAddress)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.verificationType = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.expirationTimestamp = tmp;
                },
                4 => {
                    ::protobuf::rt::read_repeated_bytes_into(wire_type, is, &mut self.allowedIssuers)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.userAddress.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.userAddress);
        }
        if self.verificationType != 0 {
            my_size += ::protobuf::rt::value_size(2, self.verificationType, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.expirationTimestamp != 0 {
            my_size += ::protobuf::rt::value_size(3, self.expirationTimestamp, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.allowedIssuers {
            my_size += ::protobuf::rt::bytes_size(4, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.userAddress.is_empty() {
            os.write_bytes(1, &self.userAddress)?;
        }
        if self.verificationType != 0 {
            os.write_uint32(2, self.verificationType)?;
        }
        if self.expirationTimestamp != 0 {
            os.write_uint32(3, self.expirationTimestamp)?;
        }
        for v in &self.allowedIssuers {
            os.write_bytes(4, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryHasVerification {
        QueryHasVerification::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "userAddress",
                    |m: &QueryHasVerification| { &m.userAddress },
                    |m: &mut QueryHasVerification| { &mut m.userAddress },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "verificationType",
                    |m: &QueryHasVerification| { &m.verificationType },
                    |m: &mut QueryHasVerification| { &mut m.verificationType },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "expirationTimestamp",
                    |m: &QueryHasVerification| { &m.expirationTimestamp },
                    |m: &mut QueryHasVerification| { &mut m.expirationTimestamp },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "allowedIssuers",
                    |m: &QueryHasVerification| { &m.allowedIssuers },
                    |m: &mut QueryHasVerification| { &mut m.allowedIssuers },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<QueryHasVerification>(
                    "QueryHasVerification",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static QueryHasVerification {
        static mut instance: ::protobuf::lazy::Lazy<QueryHasVerification> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const QueryHasVerification,
        };
        unsafe {
            instance.get(QueryHasVerification::new)
        }
    }
}

impl ::protobuf::Clear for QueryHasVerification {
    fn clear(&mut self) {
        self.userAddress.clear();
        self.verificationType = 0;
        self.expirationTimestamp = 0;
        self.allowedIssuers.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for QueryHasVerification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryHasVerification {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct QueryHasVerificationResponse {
    // message fields
    pub hasVerification: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryHasVerificationResponse {
    fn default() -> &'a QueryHasVerificationResponse {
        <QueryHasVerificationResponse as ::protobuf::Message>::default_instance()
    }
}

impl QueryHasVerificationResponse {
    pub fn new() -> QueryHasVerificationResponse {
        ::std::default::Default::default()
    }

    // bool hasVerification = 1;


    pub fn get_hasVerification(&self) -> bool {
        self.hasVerification
    }
    pub fn clear_hasVerification(&mut self) {
        self.hasVerification = false;
    }

    // Param is passed by value, moved
    pub fn set_hasVerification(&mut self, v: bool) {
        self.hasVerification = v;
    }
}

impl ::protobuf::Message for QueryHasVerificationResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.hasVerification = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.hasVerification != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.hasVerification != false {
            os.write_bool(1, self.hasVerification)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryHasVerificationResponse {
        QueryHasVerificationResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "hasVerification",
                    |m: &QueryHasVerificationResponse| { &m.hasVerification },
                    |m: &mut QueryHasVerificationResponse| { &mut m.hasVerification },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<QueryHasVerificationResponse>(
                    "QueryHasVerificationResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static QueryHasVerificationResponse {
        static mut instance: ::protobuf::lazy::Lazy<QueryHasVerificationResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const QueryHasVerificationResponse,
        };
        unsafe {
            instance.get(QueryHasVerificationResponse::new)
        }
    }
}

impl ::protobuf::Clear for QueryHasVerificationResponse {
    fn clear(&mut self) {
        self.hasVerification = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for QueryHasVerificationResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryHasVerificationResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct QueryGetVerificationData {
    // message fields
    pub userAddress: ::std::vec::Vec<u8>,
    pub issuerAddress: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryGetVerificationData {
    fn default() -> &'a QueryGetVerificationData {
        <QueryGetVerificationData as ::protobuf::Message>::default_instance()
    }
}

impl QueryGetVerificationData {
    pub fn new() -> QueryGetVerificationData {
        ::std::default::Default::default()
    }

    // bytes userAddress = 1;


    pub fn get_userAddress(&self) -> &[u8] {
        &self.userAddress
    }
    pub fn clear_userAddress(&mut self) {
        self.userAddress.clear();
    }

    // Param is passed by value, moved
    pub fn set_userAddress(&mut self, v: ::std::vec::Vec<u8>) {
        self.userAddress = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_userAddress(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.userAddress
    }

    // Take field
    pub fn take_userAddress(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.userAddress, ::std::vec::Vec::new())
    }

    // bytes issuerAddress = 2;


    pub fn get_issuerAddress(&self) -> &[u8] {
        &self.issuerAddress
    }
    pub fn clear_issuerAddress(&mut self) {
        self.issuerAddress.clear();
    }

    // Param is passed by value, moved
    pub fn set_issuerAddress(&mut self, v: ::std::vec::Vec<u8>) {
        self.issuerAddress = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_issuerAddress(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.issuerAddress
    }

    // Take field
    pub fn take_issuerAddress(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.issuerAddress, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for QueryGetVerificationData {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.userAddress)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.issuerAddress)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.userAddress.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.userAddress);
        }
        if !self.issuerAddress.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.issuerAddress);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.userAddress.is_empty() {
            os.write_bytes(1, &self.userAddress)?;
        }
        if !self.issuerAddress.is_empty() {
            os.write_bytes(2, &self.issuerAddress)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryGetVerificationData {
        QueryGetVerificationData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "userAddress",
                    |m: &QueryGetVerificationData| { &m.userAddress },
                    |m: &mut QueryGetVerificationData| { &mut m.userAddress },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "issuerAddress",
                    |m: &QueryGetVerificationData| { &m.issuerAddress },
                    |m: &mut QueryGetVerificationData| { &mut m.issuerAddress },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<QueryGetVerificationData>(
                    "QueryGetVerificationData",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static QueryGetVerificationData {
        static mut instance: ::protobuf::lazy::Lazy<QueryGetVerificationData> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const QueryGetVerificationData,
        };
        unsafe {
            instance.get(QueryGetVerificationData::new)
        }
    }
}

impl ::protobuf::Clear for QueryGetVerificationData {
    fn clear(&mut self) {
        self.userAddress.clear();
        self.issuerAddress.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for QueryGetVerificationData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryGetVerificationData {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct VerificationDetails {
    // message fields
    pub verificationType: u32,
    pub verificationID: ::std::vec::Vec<u8>,
    pub issuerAddress: ::std::vec::Vec<u8>,
    pub originChain: ::std::string::String,
    pub issuanceTimestamp: u32,
    pub expirationTimestamp: u32,
    pub originalData: ::std::vec::Vec<u8>,
    pub schema: ::std::string::String,
    pub issuerVerificationId: ::std::string::String,
    pub version: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VerificationDetails {
    fn default() -> &'a VerificationDetails {
        <VerificationDetails as ::protobuf::Message>::default_instance()
    }
}

impl VerificationDetails {
    pub fn new() -> VerificationDetails {
        ::std::default::Default::default()
    }

    // uint32 verificationType = 1;


    pub fn get_verificationType(&self) -> u32 {
        self.verificationType
    }
    pub fn clear_verificationType(&mut self) {
        self.verificationType = 0;
    }

    // Param is passed by value, moved
    pub fn set_verificationType(&mut self, v: u32) {
        self.verificationType = v;
    }

    // bytes verificationID = 2;


    pub fn get_verificationID(&self) -> &[u8] {
        &self.verificationID
    }
    pub fn clear_verificationID(&mut self) {
        self.verificationID.clear();
    }

    // Param is passed by value, moved
    pub fn set_verificationID(&mut self, v: ::std::vec::Vec<u8>) {
        self.verificationID = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_verificationID(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.verificationID
    }

    // Take field
    pub fn take_verificationID(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.verificationID, ::std::vec::Vec::new())
    }

    // bytes issuerAddress = 3;


    pub fn get_issuerAddress(&self) -> &[u8] {
        &self.issuerAddress
    }
    pub fn clear_issuerAddress(&mut self) {
        self.issuerAddress.clear();
    }

    // Param is passed by value, moved
    pub fn set_issuerAddress(&mut self, v: ::std::vec::Vec<u8>) {
        self.issuerAddress = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_issuerAddress(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.issuerAddress
    }

    // Take field
    pub fn take_issuerAddress(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.issuerAddress, ::std::vec::Vec::new())
    }

    // string originChain = 4;


    pub fn get_originChain(&self) -> &str {
        &self.originChain
    }
    pub fn clear_originChain(&mut self) {
        self.originChain.clear();
    }

    // Param is passed by value, moved
    pub fn set_originChain(&mut self, v: ::std::string::String) {
        self.originChain = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_originChain(&mut self) -> &mut ::std::string::String {
        &mut self.originChain
    }

    // Take field
    pub fn take_originChain(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.originChain, ::std::string::String::new())
    }

    // uint32 issuanceTimestamp = 5;


    pub fn get_issuanceTimestamp(&self) -> u32 {
        self.issuanceTimestamp
    }
    pub fn clear_issuanceTimestamp(&mut self) {
        self.issuanceTimestamp = 0;
    }

    // Param is passed by value, moved
    pub fn set_issuanceTimestamp(&mut self, v: u32) {
        self.issuanceTimestamp = v;
    }

    // uint32 expirationTimestamp = 6;


    pub fn get_expirationTimestamp(&self) -> u32 {
        self.expirationTimestamp
    }
    pub fn clear_expirationTimestamp(&mut self) {
        self.expirationTimestamp = 0;
    }

    // Param is passed by value, moved
    pub fn set_expirationTimestamp(&mut self, v: u32) {
        self.expirationTimestamp = v;
    }

    // bytes originalData = 7;


    pub fn get_originalData(&self) -> &[u8] {
        &self.originalData
    }
    pub fn clear_originalData(&mut self) {
        self.originalData.clear();
    }

    // Param is passed by value, moved
    pub fn set_originalData(&mut self, v: ::std::vec::Vec<u8>) {
        self.originalData = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_originalData(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.originalData
    }

    // Take field
    pub fn take_originalData(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.originalData, ::std::vec::Vec::new())
    }

    // string schema = 8;


    pub fn get_schema(&self) -> &str {
        &self.schema
    }
    pub fn clear_schema(&mut self) {
        self.schema.clear();
    }

    // Param is passed by value, moved
    pub fn set_schema(&mut self, v: ::std::string::String) {
        self.schema = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_schema(&mut self) -> &mut ::std::string::String {
        &mut self.schema
    }

    // Take field
    pub fn take_schema(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.schema, ::std::string::String::new())
    }

    // string issuerVerificationId = 9;


    pub fn get_issuerVerificationId(&self) -> &str {
        &self.issuerVerificationId
    }
    pub fn clear_issuerVerificationId(&mut self) {
        self.issuerVerificationId.clear();
    }

    // Param is passed by value, moved
    pub fn set_issuerVerificationId(&mut self, v: ::std::string::String) {
        self.issuerVerificationId = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_issuerVerificationId(&mut self) -> &mut ::std::string::String {
        &mut self.issuerVerificationId
    }

    // Take field
    pub fn take_issuerVerificationId(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.issuerVerificationId, ::std::string::String::new())
    }

    // uint32 version = 10;


    pub fn get_version(&self) -> u32 {
        self.version
    }
    pub fn clear_version(&mut self) {
        self.version = 0;
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: u32) {
        self.version = v;
    }
}

impl ::protobuf::Message for VerificationDetails {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.verificationType = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.verificationID)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.issuerAddress)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.originChain)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.issuanceTimestamp = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.expirationTimestamp = tmp;
                },
                7 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.originalData)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.schema)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.issuerVerificationId)?;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.version = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.verificationType != 0 {
            my_size += ::protobuf::rt::value_size(1, self.verificationType, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.verificationID.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.verificationID);
        }
        if !self.issuerAddress.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.issuerAddress);
        }
        if !self.originChain.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.originChain);
        }
        if self.issuanceTimestamp != 0 {
            my_size += ::protobuf::rt::value_size(5, self.issuanceTimestamp, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.expirationTimestamp != 0 {
            my_size += ::protobuf::rt::value_size(6, self.expirationTimestamp, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.originalData.is_empty() {
            my_size += ::protobuf::rt::bytes_size(7, &self.originalData);
        }
        if !self.schema.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.schema);
        }
        if !self.issuerVerificationId.is_empty() {
            my_size += ::protobuf::rt::string_size(9, &self.issuerVerificationId);
        }
        if self.version != 0 {
            my_size += ::protobuf::rt::value_size(10, self.version, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.verificationType != 0 {
            os.write_uint32(1, self.verificationType)?;
        }
        if !self.verificationID.is_empty() {
            os.write_bytes(2, &self.verificationID)?;
        }
        if !self.issuerAddress.is_empty() {
            os.write_bytes(3, &self.issuerAddress)?;
        }
        if !self.originChain.is_empty() {
            os.write_string(4, &self.originChain)?;
        }
        if self.issuanceTimestamp != 0 {
            os.write_uint32(5, self.issuanceTimestamp)?;
        }
        if self.expirationTimestamp != 0 {
            os.write_uint32(6, self.expirationTimestamp)?;
        }
        if !self.originalData.is_empty() {
            os.write_bytes(7, &self.originalData)?;
        }
        if !self.schema.is_empty() {
            os.write_string(8, &self.schema)?;
        }
        if !self.issuerVerificationId.is_empty() {
            os.write_string(9, &self.issuerVerificationId)?;
        }
        if self.version != 0 {
            os.write_uint32(10, self.version)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VerificationDetails {
        VerificationDetails::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "verificationType",
                    |m: &VerificationDetails| { &m.verificationType },
                    |m: &mut VerificationDetails| { &mut m.verificationType },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "verificationID",
                    |m: &VerificationDetails| { &m.verificationID },
                    |m: &mut VerificationDetails| { &mut m.verificationID },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "issuerAddress",
                    |m: &VerificationDetails| { &m.issuerAddress },
                    |m: &mut VerificationDetails| { &mut m.issuerAddress },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "originChain",
                    |m: &VerificationDetails| { &m.originChain },
                    |m: &mut VerificationDetails| { &mut m.originChain },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "issuanceTimestamp",
                    |m: &VerificationDetails| { &m.issuanceTimestamp },
                    |m: &mut VerificationDetails| { &mut m.issuanceTimestamp },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "expirationTimestamp",
                    |m: &VerificationDetails| { &m.expirationTimestamp },
                    |m: &mut VerificationDetails| { &mut m.expirationTimestamp },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "originalData",
                    |m: &VerificationDetails| { &m.originalData },
                    |m: &mut VerificationDetails| { &mut m.originalData },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "schema",
                    |m: &VerificationDetails| { &m.schema },
                    |m: &mut VerificationDetails| { &mut m.schema },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "issuerVerificationId",
                    |m: &VerificationDetails| { &m.issuerVerificationId },
                    |m: &mut VerificationDetails| { &mut m.issuerVerificationId },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "version",
                    |m: &VerificationDetails| { &m.version },
                    |m: &mut VerificationDetails| { &mut m.version },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<VerificationDetails>(
                    "VerificationDetails",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static VerificationDetails {
        static mut instance: ::protobuf::lazy::Lazy<VerificationDetails> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const VerificationDetails,
        };
        unsafe {
            instance.get(VerificationDetails::new)
        }
    }
}

impl ::protobuf::Clear for VerificationDetails {
    fn clear(&mut self) {
        self.verificationType = 0;
        self.verificationID.clear();
        self.issuerAddress.clear();
        self.originChain.clear();
        self.issuanceTimestamp = 0;
        self.expirationTimestamp = 0;
        self.originalData.clear();
        self.schema.clear();
        self.issuerVerificationId.clear();
        self.version = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VerificationDetails {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VerificationDetails {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct QueryGetVerificationDataResponse {
    // message fields
    pub data: ::protobuf::RepeatedField<VerificationDetails>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryGetVerificationDataResponse {
    fn default() -> &'a QueryGetVerificationDataResponse {
        <QueryGetVerificationDataResponse as ::protobuf::Message>::default_instance()
    }
}

impl QueryGetVerificationDataResponse {
    pub fn new() -> QueryGetVerificationDataResponse {
        ::std::default::Default::default()
    }

    // repeated .ffi.ffi.VerificationDetails data = 1;


    pub fn get_data(&self) -> &[VerificationDetails] {
        &self.data
    }
    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::protobuf::RepeatedField<VerificationDetails>) {
        self.data = v;
    }

    // Mutable pointer to the field.
    pub fn mut_data(&mut self) -> &mut ::protobuf::RepeatedField<VerificationDetails> {
        &mut self.data
    }

    // Take field
    pub fn take_data(&mut self) -> ::protobuf::RepeatedField<VerificationDetails> {
        ::std::mem::replace(&mut self.data, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for QueryGetVerificationDataResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.data {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.data {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.data {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryGetVerificationDataResponse {
        QueryGetVerificationDataResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<VerificationDetails>>(
                    "data",
                    |m: &QueryGetVerificationDataResponse| { &m.data },
                    |m: &mut QueryGetVerificationDataResponse| { &mut m.data },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<QueryGetVerificationDataResponse>(
                    "QueryGetVerificationDataResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static QueryGetVerificationDataResponse {
        static mut instance: ::protobuf::lazy::Lazy<QueryGetVerificationDataResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const QueryGetVerificationDataResponse,
        };
        unsafe {
            instance.get(QueryGetVerificationDataResponse::new)
        }
    }
}

impl ::protobuf::Clear for QueryGetVerificationDataResponse {
    fn clear(&mut self) {
        self.data.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for QueryGetVerificationDataResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryGetVerificationDataResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CosmosRequest {
    // message oneof groups
    pub req: ::std::option::Option<CosmosRequest_oneof_req>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CosmosRequest {
    fn default() -> &'a CosmosRequest {
        <CosmosRequest as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum CosmosRequest_oneof_req {
    getAccount(QueryGetAccount),
    insertAccount(QueryInsertAccount),
    containsKey(QueryContainsKey),
    accountCode(QueryGetAccountCode),
    storageCell(QueryGetAccountStorageCell),
    insertAccountCode(QueryInsertAccountCode),
    insertStorageCell(QueryInsertStorageCell),
    remove(QueryRemove),
    removeStorageCell(QueryRemoveStorageCell),
    removeStorage(QueryRemoveStorage),
    blockHash(QueryBlockHash),
    addVerificationDetails(QueryAddVerificationDetails),
    hasVerification(QueryHasVerification),
    getVerificationData(QueryGetVerificationData),
}

impl CosmosRequest {
    pub fn new() -> CosmosRequest {
        ::std::default::Default::default()
    }

    // .ffi.ffi.QueryGetAccount getAccount = 1;


    pub fn get_getAccount(&self) -> &QueryGetAccount {
        match self.req {
            ::std::option::Option::Some(CosmosRequest_oneof_req::getAccount(ref v)) => v,
            _ => QueryGetAccount::default_instance(),
        }
    }
    pub fn clear_getAccount(&mut self) {
        self.req = ::std::option::Option::None;
    }

    pub fn has_getAccount(&self) -> bool {
        match self.req {
            ::std::option::Option::Some(CosmosRequest_oneof_req::getAccount(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_getAccount(&mut self, v: QueryGetAccount) {
        self.req = ::std::option::Option::Some(CosmosRequest_oneof_req::getAccount(v))
    }

    // Mutable pointer to the field.
    pub fn mut_getAccount(&mut self) -> &mut QueryGetAccount {
        if let ::std::option::Option::Some(CosmosRequest_oneof_req::getAccount(_)) = self.req {
        } else {
            self.req = ::std::option::Option::Some(CosmosRequest_oneof_req::getAccount(QueryGetAccount::new()));
        }
        match self.req {
            ::std::option::Option::Some(CosmosRequest_oneof_req::getAccount(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_getAccount(&mut self) -> QueryGetAccount {
        if self.has_getAccount() {
            match self.req.take() {
                ::std::option::Option::Some(CosmosRequest_oneof_req::getAccount(v)) => v,
                _ => panic!(),
            }
        } else {
            QueryGetAccount::new()
        }
    }

    // .ffi.ffi.QueryInsertAccount insertAccount = 2;


    pub fn get_insertAccount(&self) -> &QueryInsertAccount {
        match self.req {
            ::std::option::Option::Some(CosmosRequest_oneof_req::insertAccount(ref v)) => v,
            _ => QueryInsertAccount::default_instance(),
        }
    }
    pub fn clear_insertAccount(&mut self) {
        self.req = ::std::option::Option::None;
    }

    pub fn has_insertAccount(&self) -> bool {
        match self.req {
            ::std::option::Option::Some(CosmosRequest_oneof_req::insertAccount(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_insertAccount(&mut self, v: QueryInsertAccount) {
        self.req = ::std::option::Option::Some(CosmosRequest_oneof_req::insertAccount(v))
    }

    // Mutable pointer to the field.
    pub fn mut_insertAccount(&mut self) -> &mut QueryInsertAccount {
        if let ::std::option::Option::Some(CosmosRequest_oneof_req::insertAccount(_)) = self.req {
        } else {
            self.req = ::std::option::Option::Some(CosmosRequest_oneof_req::insertAccount(QueryInsertAccount::new()));
        }
        match self.req {
            ::std::option::Option::Some(CosmosRequest_oneof_req::insertAccount(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_insertAccount(&mut self) -> QueryInsertAccount {
        if self.has_insertAccount() {
            match self.req.take() {
                ::std::option::Option::Some(CosmosRequest_oneof_req::insertAccount(v)) => v,
                _ => panic!(),
            }
        } else {
            QueryInsertAccount::new()
        }
    }

    // .ffi.ffi.QueryContainsKey containsKey = 3;


    pub fn get_containsKey(&self) -> &QueryContainsKey {
        match self.req {
            ::std::option::Option::Some(CosmosRequest_oneof_req::containsKey(ref v)) => v,
            _ => QueryContainsKey::default_instance(),
        }
    }
    pub fn clear_containsKey(&mut self) {
        self.req = ::std::option::Option::None;
    }

    pub fn has_containsKey(&self) -> bool {
        match self.req {
            ::std::option::Option::Some(CosmosRequest_oneof_req::containsKey(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_containsKey(&mut self, v: QueryContainsKey) {
        self.req = ::std::option::Option::Some(CosmosRequest_oneof_req::containsKey(v))
    }

    // Mutable pointer to the field.
    pub fn mut_containsKey(&mut self) -> &mut QueryContainsKey {
        if let ::std::option::Option::Some(CosmosRequest_oneof_req::containsKey(_)) = self.req {
        } else {
            self.req = ::std::option::Option::Some(CosmosRequest_oneof_req::containsKey(QueryContainsKey::new()));
        }
        match self.req {
            ::std::option::Option::Some(CosmosRequest_oneof_req::containsKey(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_containsKey(&mut self) -> QueryContainsKey {
        if self.has_containsKey() {
            match self.req.take() {
                ::std::option::Option::Some(CosmosRequest_oneof_req::containsKey(v)) => v,
                _ => panic!(),
            }
        } else {
            QueryContainsKey::new()
        }
    }

    // .ffi.ffi.QueryGetAccountCode accountCode = 4;


    pub fn get_accountCode(&self) -> &QueryGetAccountCode {
        match self.req {
            ::std::option::Option::Some(CosmosRequest_oneof_req::accountCode(ref v)) => v,
            _ => QueryGetAccountCode::default_instance(),
        }
    }
    pub fn clear_accountCode(&mut self) {
        self.req = ::std::option::Option::None;
    }

    pub fn has_accountCode(&self) -> bool {
        match self.req {
            ::std::option::Option::Some(CosmosRequest_oneof_req::accountCode(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_accountCode(&mut self, v: QueryGetAccountCode) {
        self.req = ::std::option::Option::Some(CosmosRequest_oneof_req::accountCode(v))
    }

    // Mutable pointer to the field.
    pub fn mut_accountCode(&mut self) -> &mut QueryGetAccountCode {
        if let ::std::option::Option::Some(CosmosRequest_oneof_req::accountCode(_)) = self.req {
        } else {
            self.req = ::std::option::Option::Some(CosmosRequest_oneof_req::accountCode(QueryGetAccountCode::new()));
        }
        match self.req {
            ::std::option::Option::Some(CosmosRequest_oneof_req::accountCode(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_accountCode(&mut self) -> QueryGetAccountCode {
        if self.has_accountCode() {
            match self.req.take() {
                ::std::option::Option::Some(CosmosRequest_oneof_req::accountCode(v)) => v,
                _ => panic!(),
            }
        } else {
            QueryGetAccountCode::new()
        }
    }

    // .ffi.ffi.QueryGetAccountStorageCell storageCell = 5;


    pub fn get_storageCell(&self) -> &QueryGetAccountStorageCell {
        match self.req {
            ::std::option::Option::Some(CosmosRequest_oneof_req::storageCell(ref v)) => v,
            _ => QueryGetAccountStorageCell::default_instance(),
        }
    }
    pub fn clear_storageCell(&mut self) {
        self.req = ::std::option::Option::None;
    }

    pub fn has_storageCell(&self) -> bool {
        match self.req {
            ::std::option::Option::Some(CosmosRequest_oneof_req::storageCell(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_storageCell(&mut self, v: QueryGetAccountStorageCell) {
        self.req = ::std::option::Option::Some(CosmosRequest_oneof_req::storageCell(v))
    }

    // Mutable pointer to the field.
    pub fn mut_storageCell(&mut self) -> &mut QueryGetAccountStorageCell {
        if let ::std::option::Option::Some(CosmosRequest_oneof_req::storageCell(_)) = self.req {
        } else {
            self.req = ::std::option::Option::Some(CosmosRequest_oneof_req::storageCell(QueryGetAccountStorageCell::new()));
        }
        match self.req {
            ::std::option::Option::Some(CosmosRequest_oneof_req::storageCell(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_storageCell(&mut self) -> QueryGetAccountStorageCell {
        if self.has_storageCell() {
            match self.req.take() {
                ::std::option::Option::Some(CosmosRequest_oneof_req::storageCell(v)) => v,
                _ => panic!(),
            }
        } else {
            QueryGetAccountStorageCell::new()
        }
    }

    // .ffi.ffi.QueryInsertAccountCode insertAccountCode = 6;


    pub fn get_insertAccountCode(&self) -> &QueryInsertAccountCode {
        match self.req {
            ::std::option::Option::Some(CosmosRequest_oneof_req::insertAccountCode(ref v)) => v,
            _ => QueryInsertAccountCode::default_instance(),
        }
    }
    pub fn clear_insertAccountCode(&mut self) {
        self.req = ::std::option::Option::None;
    }

    pub fn has_insertAccountCode(&self) -> bool {
        match self.req {
            ::std::option::Option::Some(CosmosRequest_oneof_req::insertAccountCode(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_insertAccountCode(&mut self, v: QueryInsertAccountCode) {
        self.req = ::std::option::Option::Some(CosmosRequest_oneof_req::insertAccountCode(v))
    }

    // Mutable pointer to the field.
    pub fn mut_insertAccountCode(&mut self) -> &mut QueryInsertAccountCode {
        if let ::std::option::Option::Some(CosmosRequest_oneof_req::insertAccountCode(_)) = self.req {
        } else {
            self.req = ::std::option::Option::Some(CosmosRequest_oneof_req::insertAccountCode(QueryInsertAccountCode::new()));
        }
        match self.req {
            ::std::option::Option::Some(CosmosRequest_oneof_req::insertAccountCode(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_insertAccountCode(&mut self) -> QueryInsertAccountCode {
        if self.has_insertAccountCode() {
            match self.req.take() {
                ::std::option::Option::Some(CosmosRequest_oneof_req::insertAccountCode(v)) => v,
                _ => panic!(),
            }
        } else {
            QueryInsertAccountCode::new()
        }
    }

    // .ffi.ffi.QueryInsertStorageCell insertStorageCell = 7;


    pub fn get_insertStorageCell(&self) -> &QueryInsertStorageCell {
        match self.req {
            ::std::option::Option::Some(CosmosRequest_oneof_req::insertStorageCell(ref v)) => v,
            _ => QueryInsertStorageCell::default_instance(),
        }
    }
    pub fn clear_insertStorageCell(&mut self) {
        self.req = ::std::option::Option::None;
    }

    pub fn has_insertStorageCell(&self) -> bool {
        match self.req {
            ::std::option::Option::Some(CosmosRequest_oneof_req::insertStorageCell(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_insertStorageCell(&mut self, v: QueryInsertStorageCell) {
        self.req = ::std::option::Option::Some(CosmosRequest_oneof_req::insertStorageCell(v))
    }

    // Mutable pointer to the field.
    pub fn mut_insertStorageCell(&mut self) -> &mut QueryInsertStorageCell {
        if let ::std::option::Option::Some(CosmosRequest_oneof_req::insertStorageCell(_)) = self.req {
        } else {
            self.req = ::std::option::Option::Some(CosmosRequest_oneof_req::insertStorageCell(QueryInsertStorageCell::new()));
        }
        match self.req {
            ::std::option::Option::Some(CosmosRequest_oneof_req::insertStorageCell(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_insertStorageCell(&mut self) -> QueryInsertStorageCell {
        if self.has_insertStorageCell() {
            match self.req.take() {
                ::std::option::Option::Some(CosmosRequest_oneof_req::insertStorageCell(v)) => v,
                _ => panic!(),
            }
        } else {
            QueryInsertStorageCell::new()
        }
    }

    // .ffi.ffi.QueryRemove remove = 8;


    pub fn get_remove(&self) -> &QueryRemove {
        match self.req {
            ::std::option::Option::Some(CosmosRequest_oneof_req::remove(ref v)) => v,
            _ => QueryRemove::default_instance(),
        }
    }
    pub fn clear_remove(&mut self) {
        self.req = ::std::option::Option::None;
    }

    pub fn has_remove(&self) -> bool {
        match self.req {
            ::std::option::Option::Some(CosmosRequest_oneof_req::remove(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_remove(&mut self, v: QueryRemove) {
        self.req = ::std::option::Option::Some(CosmosRequest_oneof_req::remove(v))
    }

    // Mutable pointer to the field.
    pub fn mut_remove(&mut self) -> &mut QueryRemove {
        if let ::std::option::Option::Some(CosmosRequest_oneof_req::remove(_)) = self.req {
        } else {
            self.req = ::std::option::Option::Some(CosmosRequest_oneof_req::remove(QueryRemove::new()));
        }
        match self.req {
            ::std::option::Option::Some(CosmosRequest_oneof_req::remove(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_remove(&mut self) -> QueryRemove {
        if self.has_remove() {
            match self.req.take() {
                ::std::option::Option::Some(CosmosRequest_oneof_req::remove(v)) => v,
                _ => panic!(),
            }
        } else {
            QueryRemove::new()
        }
    }

    // .ffi.ffi.QueryRemoveStorageCell removeStorageCell = 9;


    pub fn get_removeStorageCell(&self) -> &QueryRemoveStorageCell {
        match self.req {
            ::std::option::Option::Some(CosmosRequest_oneof_req::removeStorageCell(ref v)) => v,
            _ => QueryRemoveStorageCell::default_instance(),
        }
    }
    pub fn clear_removeStorageCell(&mut self) {
        self.req = ::std::option::Option::None;
    }

    pub fn has_removeStorageCell(&self) -> bool {
        match self.req {
            ::std::option::Option::Some(CosmosRequest_oneof_req::removeStorageCell(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_removeStorageCell(&mut self, v: QueryRemoveStorageCell) {
        self.req = ::std::option::Option::Some(CosmosRequest_oneof_req::removeStorageCell(v))
    }

    // Mutable pointer to the field.
    pub fn mut_removeStorageCell(&mut self) -> &mut QueryRemoveStorageCell {
        if let ::std::option::Option::Some(CosmosRequest_oneof_req::removeStorageCell(_)) = self.req {
        } else {
            self.req = ::std::option::Option::Some(CosmosRequest_oneof_req::removeStorageCell(QueryRemoveStorageCell::new()));
        }
        match self.req {
            ::std::option::Option::Some(CosmosRequest_oneof_req::removeStorageCell(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_removeStorageCell(&mut self) -> QueryRemoveStorageCell {
        if self.has_removeStorageCell() {
            match self.req.take() {
                ::std::option::Option::Some(CosmosRequest_oneof_req::removeStorageCell(v)) => v,
                _ => panic!(),
            }
        } else {
            QueryRemoveStorageCell::new()
        }
    }

    // .ffi.ffi.QueryRemoveStorage removeStorage = 10;


    pub fn get_removeStorage(&self) -> &QueryRemoveStorage {
        match self.req {
            ::std::option::Option::Some(CosmosRequest_oneof_req::removeStorage(ref v)) => v,
            _ => QueryRemoveStorage::default_instance(),
        }
    }
    pub fn clear_removeStorage(&mut self) {
        self.req = ::std::option::Option::None;
    }

    pub fn has_removeStorage(&self) -> bool {
        match self.req {
            ::std::option::Option::Some(CosmosRequest_oneof_req::removeStorage(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_removeStorage(&mut self, v: QueryRemoveStorage) {
        self.req = ::std::option::Option::Some(CosmosRequest_oneof_req::removeStorage(v))
    }

    // Mutable pointer to the field.
    pub fn mut_removeStorage(&mut self) -> &mut QueryRemoveStorage {
        if let ::std::option::Option::Some(CosmosRequest_oneof_req::removeStorage(_)) = self.req {
        } else {
            self.req = ::std::option::Option::Some(CosmosRequest_oneof_req::removeStorage(QueryRemoveStorage::new()));
        }
        match self.req {
            ::std::option::Option::Some(CosmosRequest_oneof_req::removeStorage(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_removeStorage(&mut self) -> QueryRemoveStorage {
        if self.has_removeStorage() {
            match self.req.take() {
                ::std::option::Option::Some(CosmosRequest_oneof_req::removeStorage(v)) => v,
                _ => panic!(),
            }
        } else {
            QueryRemoveStorage::new()
        }
    }

    // .ffi.ffi.QueryBlockHash blockHash = 11;


    pub fn get_blockHash(&self) -> &QueryBlockHash {
        match self.req {
            ::std::option::Option::Some(CosmosRequest_oneof_req::blockHash(ref v)) => v,
            _ => QueryBlockHash::default_instance(),
        }
    }
    pub fn clear_blockHash(&mut self) {
        self.req = ::std::option::Option::None;
    }

    pub fn has_blockHash(&self) -> bool {
        match self.req {
            ::std::option::Option::Some(CosmosRequest_oneof_req::blockHash(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_blockHash(&mut self, v: QueryBlockHash) {
        self.req = ::std::option::Option::Some(CosmosRequest_oneof_req::blockHash(v))
    }

    // Mutable pointer to the field.
    pub fn mut_blockHash(&mut self) -> &mut QueryBlockHash {
        if let ::std::option::Option::Some(CosmosRequest_oneof_req::blockHash(_)) = self.req {
        } else {
            self.req = ::std::option::Option::Some(CosmosRequest_oneof_req::blockHash(QueryBlockHash::new()));
        }
        match self.req {
            ::std::option::Option::Some(CosmosRequest_oneof_req::blockHash(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_blockHash(&mut self) -> QueryBlockHash {
        if self.has_blockHash() {
            match self.req.take() {
                ::std::option::Option::Some(CosmosRequest_oneof_req::blockHash(v)) => v,
                _ => panic!(),
            }
        } else {
            QueryBlockHash::new()
        }
    }

    // .ffi.ffi.QueryAddVerificationDetails addVerificationDetails = 12;


    pub fn get_addVerificationDetails(&self) -> &QueryAddVerificationDetails {
        match self.req {
            ::std::option::Option::Some(CosmosRequest_oneof_req::addVerificationDetails(ref v)) => v,
            _ => QueryAddVerificationDetails::default_instance(),
        }
    }
    pub fn clear_addVerificationDetails(&mut self) {
        self.req = ::std::option::Option::None;
    }

    pub fn has_addVerificationDetails(&self) -> bool {
        match self.req {
            ::std::option::Option::Some(CosmosRequest_oneof_req::addVerificationDetails(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_addVerificationDetails(&mut self, v: QueryAddVerificationDetails) {
        self.req = ::std::option::Option::Some(CosmosRequest_oneof_req::addVerificationDetails(v))
    }

    // Mutable pointer to the field.
    pub fn mut_addVerificationDetails(&mut self) -> &mut QueryAddVerificationDetails {
        if let ::std::option::Option::Some(CosmosRequest_oneof_req::addVerificationDetails(_)) = self.req {
        } else {
            self.req = ::std::option::Option::Some(CosmosRequest_oneof_req::addVerificationDetails(QueryAddVerificationDetails::new()));
        }
        match self.req {
            ::std::option::Option::Some(CosmosRequest_oneof_req::addVerificationDetails(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_addVerificationDetails(&mut self) -> QueryAddVerificationDetails {
        if self.has_addVerificationDetails() {
            match self.req.take() {
                ::std::option::Option::Some(CosmosRequest_oneof_req::addVerificationDetails(v)) => v,
                _ => panic!(),
            }
        } else {
            QueryAddVerificationDetails::new()
        }
    }

    // .ffi.ffi.QueryHasVerification hasVerification = 13;


    pub fn get_hasVerification(&self) -> &QueryHasVerification {
        match self.req {
            ::std::option::Option::Some(CosmosRequest_oneof_req::hasVerification(ref v)) => v,
            _ => QueryHasVerification::default_instance(),
        }
    }
    pub fn clear_hasVerification(&mut self) {
        self.req = ::std::option::Option::None;
    }

    pub fn has_hasVerification(&self) -> bool {
        match self.req {
            ::std::option::Option::Some(CosmosRequest_oneof_req::hasVerification(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_hasVerification(&mut self, v: QueryHasVerification) {
        self.req = ::std::option::Option::Some(CosmosRequest_oneof_req::hasVerification(v))
    }

    // Mutable pointer to the field.
    pub fn mut_hasVerification(&mut self) -> &mut QueryHasVerification {
        if let ::std::option::Option::Some(CosmosRequest_oneof_req::hasVerification(_)) = self.req {
        } else {
            self.req = ::std::option::Option::Some(CosmosRequest_oneof_req::hasVerification(QueryHasVerification::new()));
        }
        match self.req {
            ::std::option::Option::Some(CosmosRequest_oneof_req::hasVerification(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_hasVerification(&mut self) -> QueryHasVerification {
        if self.has_hasVerification() {
            match self.req.take() {
                ::std::option::Option::Some(CosmosRequest_oneof_req::hasVerification(v)) => v,
                _ => panic!(),
            }
        } else {
            QueryHasVerification::new()
        }
    }

    // .ffi.ffi.QueryGetVerificationData getVerificationData = 14;


    pub fn get_getVerificationData(&self) -> &QueryGetVerificationData {
        match self.req {
            ::std::option::Option::Some(CosmosRequest_oneof_req::getVerificationData(ref v)) => v,
            _ => QueryGetVerificationData::default_instance(),
        }
    }
    pub fn clear_getVerificationData(&mut self) {
        self.req = ::std::option::Option::None;
    }

    pub fn has_getVerificationData(&self) -> bool {
        match self.req {
            ::std::option::Option::Some(CosmosRequest_oneof_req::getVerificationData(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_getVerificationData(&mut self, v: QueryGetVerificationData) {
        self.req = ::std::option::Option::Some(CosmosRequest_oneof_req::getVerificationData(v))
    }

    // Mutable pointer to the field.
    pub fn mut_getVerificationData(&mut self) -> &mut QueryGetVerificationData {
        if let ::std::option::Option::Some(CosmosRequest_oneof_req::getVerificationData(_)) = self.req {
        } else {
            self.req = ::std::option::Option::Some(CosmosRequest_oneof_req::getVerificationData(QueryGetVerificationData::new()));
        }
        match self.req {
            ::std::option::Option::Some(CosmosRequest_oneof_req::getVerificationData(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_getVerificationData(&mut self) -> QueryGetVerificationData {
        if self.has_getVerificationData() {
            match self.req.take() {
                ::std::option::Option::Some(CosmosRequest_oneof_req::getVerificationData(v)) => v,
                _ => panic!(),
            }
        } else {
            QueryGetVerificationData::new()
        }
    }
}

impl ::protobuf::Message for CosmosRequest {
    fn is_initialized(&self) -> bool {
        if let Some(CosmosRequest_oneof_req::getAccount(ref v)) = self.req {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(CosmosRequest_oneof_req::insertAccount(ref v)) = self.req {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(CosmosRequest_oneof_req::containsKey(ref v)) = self.req {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(CosmosRequest_oneof_req::accountCode(ref v)) = self.req {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(CosmosRequest_oneof_req::storageCell(ref v)) = self.req {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(CosmosRequest_oneof_req::insertAccountCode(ref v)) = self.req {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(CosmosRequest_oneof_req::insertStorageCell(ref v)) = self.req {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(CosmosRequest_oneof_req::remove(ref v)) = self.req {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(CosmosRequest_oneof_req::removeStorageCell(ref v)) = self.req {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(CosmosRequest_oneof_req::removeStorage(ref v)) = self.req {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(CosmosRequest_oneof_req::blockHash(ref v)) = self.req {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(CosmosRequest_oneof_req::addVerificationDetails(ref v)) = self.req {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(CosmosRequest_oneof_req::hasVerification(ref v)) = self.req {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(CosmosRequest_oneof_req::getVerificationData(ref v)) = self.req {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.req = ::std::option::Option::Some(CosmosRequest_oneof_req::getAccount(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.req = ::std::option::Option::Some(CosmosRequest_oneof_req::insertAccount(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.req = ::std::option::Option::Some(CosmosRequest_oneof_req::containsKey(is.read_message()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.req = ::std::option::Option::Some(CosmosRequest_oneof_req::accountCode(is.read_message()?));
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.req = ::std::option::Option::Some(CosmosRequest_oneof_req::storageCell(is.read_message()?));
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.req = ::std::option::Option::Some(CosmosRequest_oneof_req::insertAccountCode(is.read_message()?));
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.req = ::std::option::Option::Some(CosmosRequest_oneof_req::insertStorageCell(is.read_message()?));
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.req = ::std::option::Option::Some(CosmosRequest_oneof_req::remove(is.read_message()?));
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.req = ::std::option::Option::Some(CosmosRequest_oneof_req::removeStorageCell(is.read_message()?));
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.req = ::std::option::Option::Some(CosmosRequest_oneof_req::removeStorage(is.read_message()?));
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.req = ::std::option::Option::Some(CosmosRequest_oneof_req::blockHash(is.read_message()?));
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.req = ::std::option::Option::Some(CosmosRequest_oneof_req::addVerificationDetails(is.read_message()?));
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.req = ::std::option::Option::Some(CosmosRequest_oneof_req::hasVerification(is.read_message()?));
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.req = ::std::option::Option::Some(CosmosRequest_oneof_req::getVerificationData(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.req {
            match v {
                &CosmosRequest_oneof_req::getAccount(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &CosmosRequest_oneof_req::insertAccount(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &CosmosRequest_oneof_req::containsKey(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &CosmosRequest_oneof_req::accountCode(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &CosmosRequest_oneof_req::storageCell(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &CosmosRequest_oneof_req::insertAccountCode(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &CosmosRequest_oneof_req::insertStorageCell(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &CosmosRequest_oneof_req::remove(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &CosmosRequest_oneof_req::removeStorageCell(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &CosmosRequest_oneof_req::removeStorage(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &CosmosRequest_oneof_req::blockHash(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &CosmosRequest_oneof_req::addVerificationDetails(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &CosmosRequest_oneof_req::hasVerification(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &CosmosRequest_oneof_req::getVerificationData(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.req {
            match v {
                &CosmosRequest_oneof_req::getAccount(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &CosmosRequest_oneof_req::insertAccount(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &CosmosRequest_oneof_req::containsKey(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &CosmosRequest_oneof_req::accountCode(ref v) => {
                    os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &CosmosRequest_oneof_req::storageCell(ref v) => {
                    os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &CosmosRequest_oneof_req::insertAccountCode(ref v) => {
                    os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &CosmosRequest_oneof_req::insertStorageCell(ref v) => {
                    os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &CosmosRequest_oneof_req::remove(ref v) => {
                    os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &CosmosRequest_oneof_req::removeStorageCell(ref v) => {
                    os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &CosmosRequest_oneof_req::removeStorage(ref v) => {
                    os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &CosmosRequest_oneof_req::blockHash(ref v) => {
                    os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &CosmosRequest_oneof_req::addVerificationDetails(ref v) => {
                    os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &CosmosRequest_oneof_req::hasVerification(ref v) => {
                    os.write_tag(13, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &CosmosRequest_oneof_req::getVerificationData(ref v) => {
                    os.write_tag(14, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CosmosRequest {
        CosmosRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, QueryGetAccount>(
                    "getAccount",
                    CosmosRequest::has_getAccount,
                    CosmosRequest::get_getAccount,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, QueryInsertAccount>(
                    "insertAccount",
                    CosmosRequest::has_insertAccount,
                    CosmosRequest::get_insertAccount,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, QueryContainsKey>(
                    "containsKey",
                    CosmosRequest::has_containsKey,
                    CosmosRequest::get_containsKey,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, QueryGetAccountCode>(
                    "accountCode",
                    CosmosRequest::has_accountCode,
                    CosmosRequest::get_accountCode,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, QueryGetAccountStorageCell>(
                    "storageCell",
                    CosmosRequest::has_storageCell,
                    CosmosRequest::get_storageCell,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, QueryInsertAccountCode>(
                    "insertAccountCode",
                    CosmosRequest::has_insertAccountCode,
                    CosmosRequest::get_insertAccountCode,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, QueryInsertStorageCell>(
                    "insertStorageCell",
                    CosmosRequest::has_insertStorageCell,
                    CosmosRequest::get_insertStorageCell,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, QueryRemove>(
                    "remove",
                    CosmosRequest::has_remove,
                    CosmosRequest::get_remove,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, QueryRemoveStorageCell>(
                    "removeStorageCell",
                    CosmosRequest::has_removeStorageCell,
                    CosmosRequest::get_removeStorageCell,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, QueryRemoveStorage>(
                    "removeStorage",
                    CosmosRequest::has_removeStorage,
                    CosmosRequest::get_removeStorage,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, QueryBlockHash>(
                    "blockHash",
                    CosmosRequest::has_blockHash,
                    CosmosRequest::get_blockHash,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, QueryAddVerificationDetails>(
                    "addVerificationDetails",
                    CosmosRequest::has_addVerificationDetails,
                    CosmosRequest::get_addVerificationDetails,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, QueryHasVerification>(
                    "hasVerification",
                    CosmosRequest::has_hasVerification,
                    CosmosRequest::get_hasVerification,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, QueryGetVerificationData>(
                    "getVerificationData",
                    CosmosRequest::has_getVerificationData,
                    CosmosRequest::get_getVerificationData,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CosmosRequest>(
                    "CosmosRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CosmosRequest {
        static mut instance: ::protobuf::lazy::Lazy<CosmosRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CosmosRequest,
        };
        unsafe {
            instance.get(CosmosRequest::new)
        }
    }
}

impl ::protobuf::Clear for CosmosRequest {
    fn clear(&mut self) {
        self.req = ::std::option::Option::None;
        self.req = ::std::option::Option::None;
        self.req = ::std::option::Option::None;
        self.req = ::std::option::Option::None;
        self.req = ::std::option::Option::None;
        self.req = ::std::option::Option::None;
        self.req = ::std::option::Option::None;
        self.req = ::std::option::Option::None;
        self.req = ::std::option::Option::None;
        self.req = ::std::option::Option::None;
        self.req = ::std::option::Option::None;
        self.req = ::std::option::Option::None;
        self.req = ::std::option::Option::None;
        self.req = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CosmosRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CosmosRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SGXVMCallParams {
    // message fields
    pub from: ::std::vec::Vec<u8>,
    pub to: ::std::vec::Vec<u8>,
    pub data: ::std::vec::Vec<u8>,
    pub gasLimit: u64,
    pub value: ::std::vec::Vec<u8>,
    pub accessList: ::protobuf::RepeatedField<AccessListItem>,
    pub commit: bool,
    pub nonce: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SGXVMCallParams {
    fn default() -> &'a SGXVMCallParams {
        <SGXVMCallParams as ::protobuf::Message>::default_instance()
    }
}

impl SGXVMCallParams {
    pub fn new() -> SGXVMCallParams {
        ::std::default::Default::default()
    }

    // bytes from = 1;


    pub fn get_from(&self) -> &[u8] {
        &self.from
    }
    pub fn clear_from(&mut self) {
        self.from.clear();
    }

    // Param is passed by value, moved
    pub fn set_from(&mut self, v: ::std::vec::Vec<u8>) {
        self.from = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_from(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.from
    }

    // Take field
    pub fn take_from(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.from, ::std::vec::Vec::new())
    }

    // bytes to = 2;


    pub fn get_to(&self) -> &[u8] {
        &self.to
    }
    pub fn clear_to(&mut self) {
        self.to.clear();
    }

    // Param is passed by value, moved
    pub fn set_to(&mut self, v: ::std::vec::Vec<u8>) {
        self.to = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_to(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.to
    }

    // Take field
    pub fn take_to(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.to, ::std::vec::Vec::new())
    }

    // bytes data = 3;


    pub fn get_data(&self) -> &[u8] {
        &self.data
    }
    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.data
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.data, ::std::vec::Vec::new())
    }

    // uint64 gasLimit = 4;


    pub fn get_gasLimit(&self) -> u64 {
        self.gasLimit
    }
    pub fn clear_gasLimit(&mut self) {
        self.gasLimit = 0;
    }

    // Param is passed by value, moved
    pub fn set_gasLimit(&mut self, v: u64) {
        self.gasLimit = v;
    }

    // bytes value = 5;


    pub fn get_value(&self) -> &[u8] {
        &self.value
    }
    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::vec::Vec<u8>) {
        self.value = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.value
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.value, ::std::vec::Vec::new())
    }

    // repeated .ffi.ffi.AccessListItem accessList = 6;


    pub fn get_accessList(&self) -> &[AccessListItem] {
        &self.accessList
    }
    pub fn clear_accessList(&mut self) {
        self.accessList.clear();
    }

    // Param is passed by value, moved
    pub fn set_accessList(&mut self, v: ::protobuf::RepeatedField<AccessListItem>) {
        self.accessList = v;
    }

    // Mutable pointer to the field.
    pub fn mut_accessList(&mut self) -> &mut ::protobuf::RepeatedField<AccessListItem> {
        &mut self.accessList
    }

    // Take field
    pub fn take_accessList(&mut self) -> ::protobuf::RepeatedField<AccessListItem> {
        ::std::mem::replace(&mut self.accessList, ::protobuf::RepeatedField::new())
    }

    // bool commit = 7;


    pub fn get_commit(&self) -> bool {
        self.commit
    }
    pub fn clear_commit(&mut self) {
        self.commit = false;
    }

    // Param is passed by value, moved
    pub fn set_commit(&mut self, v: bool) {
        self.commit = v;
    }

    // uint64 nonce = 8;


    pub fn get_nonce(&self) -> u64 {
        self.nonce
    }
    pub fn clear_nonce(&mut self) {
        self.nonce = 0;
    }

    // Param is passed by value, moved
    pub fn set_nonce(&mut self, v: u64) {
        self.nonce = v;
    }
}

impl ::protobuf::Message for SGXVMCallParams {
    fn is_initialized(&self) -> bool {
        for v in &self.accessList {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.from)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.to)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.data)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.gasLimit = tmp;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.value)?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.accessList)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.commit = tmp;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.nonce = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.from.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.from);
        }
        if !self.to.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.to);
        }
        if !self.data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.data);
        }
        if self.gasLimit != 0 {
            my_size += ::protobuf::rt::value_size(4, self.gasLimit, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.value.is_empty() {
            my_size += ::protobuf::rt::bytes_size(5, &self.value);
        }
        for value in &self.accessList {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.commit != false {
            my_size += 2;
        }
        if self.nonce != 0 {
            my_size += ::protobuf::rt::value_size(8, self.nonce, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.from.is_empty() {
            os.write_bytes(1, &self.from)?;
        }
        if !self.to.is_empty() {
            os.write_bytes(2, &self.to)?;
        }
        if !self.data.is_empty() {
            os.write_bytes(3, &self.data)?;
        }
        if self.gasLimit != 0 {
            os.write_uint64(4, self.gasLimit)?;
        }
        if !self.value.is_empty() {
            os.write_bytes(5, &self.value)?;
        }
        for v in &self.accessList {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.commit != false {
            os.write_bool(7, self.commit)?;
        }
        if self.nonce != 0 {
            os.write_uint64(8, self.nonce)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SGXVMCallParams {
        SGXVMCallParams::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "from",
                    |m: &SGXVMCallParams| { &m.from },
                    |m: &mut SGXVMCallParams| { &mut m.from },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "to",
                    |m: &SGXVMCallParams| { &m.to },
                    |m: &mut SGXVMCallParams| { &mut m.to },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "data",
                    |m: &SGXVMCallParams| { &m.data },
                    |m: &mut SGXVMCallParams| { &mut m.data },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "gasLimit",
                    |m: &SGXVMCallParams| { &m.gasLimit },
                    |m: &mut SGXVMCallParams| { &mut m.gasLimit },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "value",
                    |m: &SGXVMCallParams| { &m.value },
                    |m: &mut SGXVMCallParams| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AccessListItem>>(
                    "accessList",
                    |m: &SGXVMCallParams| { &m.accessList },
                    |m: &mut SGXVMCallParams| { &mut m.accessList },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "commit",
                    |m: &SGXVMCallParams| { &m.commit },
                    |m: &mut SGXVMCallParams| { &mut m.commit },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "nonce",
                    |m: &SGXVMCallParams| { &m.nonce },
                    |m: &mut SGXVMCallParams| { &mut m.nonce },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SGXVMCallParams>(
                    "SGXVMCallParams",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SGXVMCallParams {
        static mut instance: ::protobuf::lazy::Lazy<SGXVMCallParams> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SGXVMCallParams,
        };
        unsafe {
            instance.get(SGXVMCallParams::new)
        }
    }
}

impl ::protobuf::Clear for SGXVMCallParams {
    fn clear(&mut self) {
        self.from.clear();
        self.to.clear();
        self.data.clear();
        self.gasLimit = 0;
        self.value.clear();
        self.accessList.clear();
        self.commit = false;
        self.nonce = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SGXVMCallParams {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SGXVMCallParams {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SGXVMCreateParams {
    // message fields
    pub from: ::std::vec::Vec<u8>,
    pub data: ::std::vec::Vec<u8>,
    pub gasLimit: u64,
    pub value: ::std::vec::Vec<u8>,
    pub accessList: ::protobuf::RepeatedField<AccessListItem>,
    pub commit: bool,
    pub nonce: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SGXVMCreateParams {
    fn default() -> &'a SGXVMCreateParams {
        <SGXVMCreateParams as ::protobuf::Message>::default_instance()
    }
}

impl SGXVMCreateParams {
    pub fn new() -> SGXVMCreateParams {
        ::std::default::Default::default()
    }

    // bytes from = 1;


    pub fn get_from(&self) -> &[u8] {
        &self.from
    }
    pub fn clear_from(&mut self) {
        self.from.clear();
    }

    // Param is passed by value, moved
    pub fn set_from(&mut self, v: ::std::vec::Vec<u8>) {
        self.from = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_from(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.from
    }

    // Take field
    pub fn take_from(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.from, ::std::vec::Vec::new())
    }

    // bytes data = 2;


    pub fn get_data(&self) -> &[u8] {
        &self.data
    }
    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.data
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.data, ::std::vec::Vec::new())
    }

    // uint64 gasLimit = 3;


    pub fn get_gasLimit(&self) -> u64 {
        self.gasLimit
    }
    pub fn clear_gasLimit(&mut self) {
        self.gasLimit = 0;
    }

    // Param is passed by value, moved
    pub fn set_gasLimit(&mut self, v: u64) {
        self.gasLimit = v;
    }

    // bytes value = 4;


    pub fn get_value(&self) -> &[u8] {
        &self.value
    }
    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::vec::Vec<u8>) {
        self.value = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.value
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.value, ::std::vec::Vec::new())
    }

    // repeated .ffi.ffi.AccessListItem accessList = 5;


    pub fn get_accessList(&self) -> &[AccessListItem] {
        &self.accessList
    }
    pub fn clear_accessList(&mut self) {
        self.accessList.clear();
    }

    // Param is passed by value, moved
    pub fn set_accessList(&mut self, v: ::protobuf::RepeatedField<AccessListItem>) {
        self.accessList = v;
    }

    // Mutable pointer to the field.
    pub fn mut_accessList(&mut self) -> &mut ::protobuf::RepeatedField<AccessListItem> {
        &mut self.accessList
    }

    // Take field
    pub fn take_accessList(&mut self) -> ::protobuf::RepeatedField<AccessListItem> {
        ::std::mem::replace(&mut self.accessList, ::protobuf::RepeatedField::new())
    }

    // bool commit = 6;


    pub fn get_commit(&self) -> bool {
        self.commit
    }
    pub fn clear_commit(&mut self) {
        self.commit = false;
    }

    // Param is passed by value, moved
    pub fn set_commit(&mut self, v: bool) {
        self.commit = v;
    }

    // uint64 nonce = 7;


    pub fn get_nonce(&self) -> u64 {
        self.nonce
    }
    pub fn clear_nonce(&mut self) {
        self.nonce = 0;
    }

    // Param is passed by value, moved
    pub fn set_nonce(&mut self, v: u64) {
        self.nonce = v;
    }
}

impl ::protobuf::Message for SGXVMCreateParams {
    fn is_initialized(&self) -> bool {
        for v in &self.accessList {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.from)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.data)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.gasLimit = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.value)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.accessList)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.commit = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.nonce = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.from.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.from);
        }
        if !self.data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.data);
        }
        if self.gasLimit != 0 {
            my_size += ::protobuf::rt::value_size(3, self.gasLimit, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.value.is_empty() {
            my_size += ::protobuf::rt::bytes_size(4, &self.value);
        }
        for value in &self.accessList {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.commit != false {
            my_size += 2;
        }
        if self.nonce != 0 {
            my_size += ::protobuf::rt::value_size(7, self.nonce, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.from.is_empty() {
            os.write_bytes(1, &self.from)?;
        }
        if !self.data.is_empty() {
            os.write_bytes(2, &self.data)?;
        }
        if self.gasLimit != 0 {
            os.write_uint64(3, self.gasLimit)?;
        }
        if !self.value.is_empty() {
            os.write_bytes(4, &self.value)?;
        }
        for v in &self.accessList {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.commit != false {
            os.write_bool(6, self.commit)?;
        }
        if self.nonce != 0 {
            os.write_uint64(7, self.nonce)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SGXVMCreateParams {
        SGXVMCreateParams::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "from",
                    |m: &SGXVMCreateParams| { &m.from },
                    |m: &mut SGXVMCreateParams| { &mut m.from },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "data",
                    |m: &SGXVMCreateParams| { &m.data },
                    |m: &mut SGXVMCreateParams| { &mut m.data },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "gasLimit",
                    |m: &SGXVMCreateParams| { &m.gasLimit },
                    |m: &mut SGXVMCreateParams| { &mut m.gasLimit },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "value",
                    |m: &SGXVMCreateParams| { &m.value },
                    |m: &mut SGXVMCreateParams| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AccessListItem>>(
                    "accessList",
                    |m: &SGXVMCreateParams| { &m.accessList },
                    |m: &mut SGXVMCreateParams| { &mut m.accessList },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "commit",
                    |m: &SGXVMCreateParams| { &m.commit },
                    |m: &mut SGXVMCreateParams| { &mut m.commit },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "nonce",
                    |m: &SGXVMCreateParams| { &m.nonce },
                    |m: &mut SGXVMCreateParams| { &mut m.nonce },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SGXVMCreateParams>(
                    "SGXVMCreateParams",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SGXVMCreateParams {
        static mut instance: ::protobuf::lazy::Lazy<SGXVMCreateParams> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SGXVMCreateParams,
        };
        unsafe {
            instance.get(SGXVMCreateParams::new)
        }
    }
}

impl ::protobuf::Clear for SGXVMCreateParams {
    fn clear(&mut self) {
        self.from.clear();
        self.data.clear();
        self.gasLimit = 0;
        self.value.clear();
        self.accessList.clear();
        self.commit = false;
        self.nonce = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SGXVMCreateParams {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SGXVMCreateParams {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SGXVMCallRequest {
    // message fields
    pub params: ::protobuf::SingularPtrField<SGXVMCallParams>,
    pub context: ::protobuf::SingularPtrField<TransactionContext>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SGXVMCallRequest {
    fn default() -> &'a SGXVMCallRequest {
        <SGXVMCallRequest as ::protobuf::Message>::default_instance()
    }
}

impl SGXVMCallRequest {
    pub fn new() -> SGXVMCallRequest {
        ::std::default::Default::default()
    }

    // .ffi.ffi.SGXVMCallParams params = 1;


    pub fn get_params(&self) -> &SGXVMCallParams {
        self.params.as_ref().unwrap_or_else(|| SGXVMCallParams::default_instance())
    }
    pub fn clear_params(&mut self) {
        self.params.clear();
    }

    pub fn has_params(&self) -> bool {
        self.params.is_some()
    }

    // Param is passed by value, moved
    pub fn set_params(&mut self, v: SGXVMCallParams) {
        self.params = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_params(&mut self) -> &mut SGXVMCallParams {
        if self.params.is_none() {
            self.params.set_default();
        }
        self.params.as_mut().unwrap()
    }

    // Take field
    pub fn take_params(&mut self) -> SGXVMCallParams {
        self.params.take().unwrap_or_else(|| SGXVMCallParams::new())
    }

    // .ffi.ffi.TransactionContext context = 2;


    pub fn get_context(&self) -> &TransactionContext {
        self.context.as_ref().unwrap_or_else(|| TransactionContext::default_instance())
    }
    pub fn clear_context(&mut self) {
        self.context.clear();
    }

    pub fn has_context(&self) -> bool {
        self.context.is_some()
    }

    // Param is passed by value, moved
    pub fn set_context(&mut self, v: TransactionContext) {
        self.context = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_context(&mut self) -> &mut TransactionContext {
        if self.context.is_none() {
            self.context.set_default();
        }
        self.context.as_mut().unwrap()
    }

    // Take field
    pub fn take_context(&mut self) -> TransactionContext {
        self.context.take().unwrap_or_else(|| TransactionContext::new())
    }
}

impl ::protobuf::Message for SGXVMCallRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.params {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.context {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.params)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.context)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.params.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.context.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.params.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.context.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SGXVMCallRequest {
        SGXVMCallRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SGXVMCallParams>>(
                    "params",
                    |m: &SGXVMCallRequest| { &m.params },
                    |m: &mut SGXVMCallRequest| { &mut m.params },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TransactionContext>>(
                    "context",
                    |m: &SGXVMCallRequest| { &m.context },
                    |m: &mut SGXVMCallRequest| { &mut m.context },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SGXVMCallRequest>(
                    "SGXVMCallRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SGXVMCallRequest {
        static mut instance: ::protobuf::lazy::Lazy<SGXVMCallRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SGXVMCallRequest,
        };
        unsafe {
            instance.get(SGXVMCallRequest::new)
        }
    }
}

impl ::protobuf::Clear for SGXVMCallRequest {
    fn clear(&mut self) {
        self.params.clear();
        self.context.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SGXVMCallRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SGXVMCallRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SGXVMCreateRequest {
    // message fields
    pub params: ::protobuf::SingularPtrField<SGXVMCreateParams>,
    pub context: ::protobuf::SingularPtrField<TransactionContext>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SGXVMCreateRequest {
    fn default() -> &'a SGXVMCreateRequest {
        <SGXVMCreateRequest as ::protobuf::Message>::default_instance()
    }
}

impl SGXVMCreateRequest {
    pub fn new() -> SGXVMCreateRequest {
        ::std::default::Default::default()
    }

    // .ffi.ffi.SGXVMCreateParams params = 1;


    pub fn get_params(&self) -> &SGXVMCreateParams {
        self.params.as_ref().unwrap_or_else(|| SGXVMCreateParams::default_instance())
    }
    pub fn clear_params(&mut self) {
        self.params.clear();
    }

    pub fn has_params(&self) -> bool {
        self.params.is_some()
    }

    // Param is passed by value, moved
    pub fn set_params(&mut self, v: SGXVMCreateParams) {
        self.params = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_params(&mut self) -> &mut SGXVMCreateParams {
        if self.params.is_none() {
            self.params.set_default();
        }
        self.params.as_mut().unwrap()
    }

    // Take field
    pub fn take_params(&mut self) -> SGXVMCreateParams {
        self.params.take().unwrap_or_else(|| SGXVMCreateParams::new())
    }

    // .ffi.ffi.TransactionContext context = 2;


    pub fn get_context(&self) -> &TransactionContext {
        self.context.as_ref().unwrap_or_else(|| TransactionContext::default_instance())
    }
    pub fn clear_context(&mut self) {
        self.context.clear();
    }

    pub fn has_context(&self) -> bool {
        self.context.is_some()
    }

    // Param is passed by value, moved
    pub fn set_context(&mut self, v: TransactionContext) {
        self.context = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_context(&mut self) -> &mut TransactionContext {
        if self.context.is_none() {
            self.context.set_default();
        }
        self.context.as_mut().unwrap()
    }

    // Take field
    pub fn take_context(&mut self) -> TransactionContext {
        self.context.take().unwrap_or_else(|| TransactionContext::new())
    }
}

impl ::protobuf::Message for SGXVMCreateRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.params {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.context {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.params)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.context)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.params.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.context.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.params.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.context.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SGXVMCreateRequest {
        SGXVMCreateRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SGXVMCreateParams>>(
                    "params",
                    |m: &SGXVMCreateRequest| { &m.params },
                    |m: &mut SGXVMCreateRequest| { &mut m.params },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TransactionContext>>(
                    "context",
                    |m: &SGXVMCreateRequest| { &m.context },
                    |m: &mut SGXVMCreateRequest| { &mut m.context },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SGXVMCreateRequest>(
                    "SGXVMCreateRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SGXVMCreateRequest {
        static mut instance: ::protobuf::lazy::Lazy<SGXVMCreateRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SGXVMCreateRequest,
        };
        unsafe {
            instance.get(SGXVMCreateRequest::new)
        }
    }
}

impl ::protobuf::Clear for SGXVMCreateRequest {
    fn clear(&mut self) {
        self.params.clear();
        self.context.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SGXVMCreateRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SGXVMCreateRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct NodePublicKeyRequest {
    // message fields
    pub blockNumber: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a NodePublicKeyRequest {
    fn default() -> &'a NodePublicKeyRequest {
        <NodePublicKeyRequest as ::protobuf::Message>::default_instance()
    }
}

impl NodePublicKeyRequest {
    pub fn new() -> NodePublicKeyRequest {
        ::std::default::Default::default()
    }

    // uint64 blockNumber = 1;


    pub fn get_blockNumber(&self) -> u64 {
        self.blockNumber
    }
    pub fn clear_blockNumber(&mut self) {
        self.blockNumber = 0;
    }

    // Param is passed by value, moved
    pub fn set_blockNumber(&mut self, v: u64) {
        self.blockNumber = v;
    }
}

impl ::protobuf::Message for NodePublicKeyRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.blockNumber = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.blockNumber != 0 {
            my_size += ::protobuf::rt::value_size(1, self.blockNumber, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.blockNumber != 0 {
            os.write_uint64(1, self.blockNumber)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NodePublicKeyRequest {
        NodePublicKeyRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "blockNumber",
                    |m: &NodePublicKeyRequest| { &m.blockNumber },
                    |m: &mut NodePublicKeyRequest| { &mut m.blockNumber },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<NodePublicKeyRequest>(
                    "NodePublicKeyRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static NodePublicKeyRequest {
        static mut instance: ::protobuf::lazy::Lazy<NodePublicKeyRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const NodePublicKeyRequest,
        };
        unsafe {
            instance.get(NodePublicKeyRequest::new)
        }
    }
}

impl ::protobuf::Clear for NodePublicKeyRequest {
    fn clear(&mut self) {
        self.blockNumber = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NodePublicKeyRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NodePublicKeyRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct NodePublicKeyResponse {
    // message fields
    pub publicKey: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a NodePublicKeyResponse {
    fn default() -> &'a NodePublicKeyResponse {
        <NodePublicKeyResponse as ::protobuf::Message>::default_instance()
    }
}

impl NodePublicKeyResponse {
    pub fn new() -> NodePublicKeyResponse {
        ::std::default::Default::default()
    }

    // bytes publicKey = 1;


    pub fn get_publicKey(&self) -> &[u8] {
        &self.publicKey
    }
    pub fn clear_publicKey(&mut self) {
        self.publicKey.clear();
    }

    // Param is passed by value, moved
    pub fn set_publicKey(&mut self, v: ::std::vec::Vec<u8>) {
        self.publicKey = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_publicKey(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.publicKey
    }

    // Take field
    pub fn take_publicKey(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.publicKey, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for NodePublicKeyResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.publicKey)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.publicKey.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.publicKey);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.publicKey.is_empty() {
            os.write_bytes(1, &self.publicKey)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NodePublicKeyResponse {
        NodePublicKeyResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "publicKey",
                    |m: &NodePublicKeyResponse| { &m.publicKey },
                    |m: &mut NodePublicKeyResponse| { &mut m.publicKey },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<NodePublicKeyResponse>(
                    "NodePublicKeyResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static NodePublicKeyResponse {
        static mut instance: ::protobuf::lazy::Lazy<NodePublicKeyResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const NodePublicKeyResponse,
        };
        unsafe {
            instance.get(NodePublicKeyResponse::new)
        }
    }
}

impl ::protobuf::Clear for NodePublicKeyResponse {
    fn clear(&mut self) {
        self.publicKey.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NodePublicKeyResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NodePublicKeyResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EpochData {
    // message fields
    pub epochNumber: u32,
    pub startingBlock: u64,
    pub nodePublicKey: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EpochData {
    fn default() -> &'a EpochData {
        <EpochData as ::protobuf::Message>::default_instance()
    }
}

impl EpochData {
    pub fn new() -> EpochData {
        ::std::default::Default::default()
    }

    // uint32 epochNumber = 1;


    pub fn get_epochNumber(&self) -> u32 {
        self.epochNumber
    }
    pub fn clear_epochNumber(&mut self) {
        self.epochNumber = 0;
    }

    // Param is passed by value, moved
    pub fn set_epochNumber(&mut self, v: u32) {
        self.epochNumber = v;
    }

    // uint64 startingBlock = 2;


    pub fn get_startingBlock(&self) -> u64 {
        self.startingBlock
    }
    pub fn clear_startingBlock(&mut self) {
        self.startingBlock = 0;
    }

    // Param is passed by value, moved
    pub fn set_startingBlock(&mut self, v: u64) {
        self.startingBlock = v;
    }

    // bytes nodePublicKey = 3;


    pub fn get_nodePublicKey(&self) -> &[u8] {
        &self.nodePublicKey
    }
    pub fn clear_nodePublicKey(&mut self) {
        self.nodePublicKey.clear();
    }

    // Param is passed by value, moved
    pub fn set_nodePublicKey(&mut self, v: ::std::vec::Vec<u8>) {
        self.nodePublicKey = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_nodePublicKey(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.nodePublicKey
    }

    // Take field
    pub fn take_nodePublicKey(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.nodePublicKey, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for EpochData {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.epochNumber = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.startingBlock = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.nodePublicKey)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.epochNumber != 0 {
            my_size += ::protobuf::rt::value_size(1, self.epochNumber, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.startingBlock != 0 {
            my_size += ::protobuf::rt::value_size(2, self.startingBlock, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.nodePublicKey.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.nodePublicKey);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.epochNumber != 0 {
            os.write_uint32(1, self.epochNumber)?;
        }
        if self.startingBlock != 0 {
            os.write_uint64(2, self.startingBlock)?;
        }
        if !self.nodePublicKey.is_empty() {
            os.write_bytes(3, &self.nodePublicKey)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EpochData {
        EpochData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "epochNumber",
                    |m: &EpochData| { &m.epochNumber },
                    |m: &mut EpochData| { &mut m.epochNumber },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "startingBlock",
                    |m: &EpochData| { &m.startingBlock },
                    |m: &mut EpochData| { &mut m.startingBlock },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "nodePublicKey",
                    |m: &EpochData| { &m.nodePublicKey },
                    |m: &mut EpochData| { &mut m.nodePublicKey },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<EpochData>(
                    "EpochData",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static EpochData {
        static mut instance: ::protobuf::lazy::Lazy<EpochData> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const EpochData,
        };
        unsafe {
            instance.get(EpochData::new)
        }
    }
}

impl ::protobuf::Clear for EpochData {
    fn clear(&mut self) {
        self.epochNumber = 0;
        self.startingBlock = 0;
        self.nodePublicKey.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EpochData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EpochData {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListEpochsResponse {
    // message fields
    pub epochs: ::protobuf::RepeatedField<EpochData>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListEpochsResponse {
    fn default() -> &'a ListEpochsResponse {
        <ListEpochsResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListEpochsResponse {
    pub fn new() -> ListEpochsResponse {
        ::std::default::Default::default()
    }

    // repeated .ffi.ffi.EpochData epochs = 1;


    pub fn get_epochs(&self) -> &[EpochData] {
        &self.epochs
    }
    pub fn clear_epochs(&mut self) {
        self.epochs.clear();
    }

    // Param is passed by value, moved
    pub fn set_epochs(&mut self, v: ::protobuf::RepeatedField<EpochData>) {
        self.epochs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_epochs(&mut self) -> &mut ::protobuf::RepeatedField<EpochData> {
        &mut self.epochs
    }

    // Take field
    pub fn take_epochs(&mut self) -> ::protobuf::RepeatedField<EpochData> {
        ::std::mem::replace(&mut self.epochs, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ListEpochsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.epochs {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.epochs)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.epochs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.epochs {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListEpochsResponse {
        ListEpochsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<EpochData>>(
                    "epochs",
                    |m: &ListEpochsResponse| { &m.epochs },
                    |m: &mut ListEpochsResponse| { &mut m.epochs },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ListEpochsResponse>(
                    "ListEpochsResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ListEpochsResponse {
        static mut instance: ::protobuf::lazy::Lazy<ListEpochsResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ListEpochsResponse,
        };
        unsafe {
            instance.get(ListEpochsResponse::new)
        }
    }
}

impl ::protobuf::Clear for ListEpochsResponse {
    fn clear(&mut self) {
        self.epochs.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListEpochsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListEpochsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FFIRequest {
    // message oneof groups
    pub req: ::std::option::Option<FFIRequest_oneof_req>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FFIRequest {
    fn default() -> &'a FFIRequest {
        <FFIRequest as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum FFIRequest_oneof_req {
    callRequest(SGXVMCallRequest),
    createRequest(SGXVMCreateRequest),
    publicKeyRequest(NodePublicKeyRequest),
}

impl FFIRequest {
    pub fn new() -> FFIRequest {
        ::std::default::Default::default()
    }

    // .ffi.ffi.SGXVMCallRequest callRequest = 1;


    pub fn get_callRequest(&self) -> &SGXVMCallRequest {
        match self.req {
            ::std::option::Option::Some(FFIRequest_oneof_req::callRequest(ref v)) => v,
            _ => SGXVMCallRequest::default_instance(),
        }
    }
    pub fn clear_callRequest(&mut self) {
        self.req = ::std::option::Option::None;
    }

    pub fn has_callRequest(&self) -> bool {
        match self.req {
            ::std::option::Option::Some(FFIRequest_oneof_req::callRequest(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_callRequest(&mut self, v: SGXVMCallRequest) {
        self.req = ::std::option::Option::Some(FFIRequest_oneof_req::callRequest(v))
    }

    // Mutable pointer to the field.
    pub fn mut_callRequest(&mut self) -> &mut SGXVMCallRequest {
        if let ::std::option::Option::Some(FFIRequest_oneof_req::callRequest(_)) = self.req {
        } else {
            self.req = ::std::option::Option::Some(FFIRequest_oneof_req::callRequest(SGXVMCallRequest::new()));
        }
        match self.req {
            ::std::option::Option::Some(FFIRequest_oneof_req::callRequest(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_callRequest(&mut self) -> SGXVMCallRequest {
        if self.has_callRequest() {
            match self.req.take() {
                ::std::option::Option::Some(FFIRequest_oneof_req::callRequest(v)) => v,
                _ => panic!(),
            }
        } else {
            SGXVMCallRequest::new()
        }
    }

    // .ffi.ffi.SGXVMCreateRequest createRequest = 2;


    pub fn get_createRequest(&self) -> &SGXVMCreateRequest {
        match self.req {
            ::std::option::Option::Some(FFIRequest_oneof_req::createRequest(ref v)) => v,
            _ => SGXVMCreateRequest::default_instance(),
        }
    }
    pub fn clear_createRequest(&mut self) {
        self.req = ::std::option::Option::None;
    }

    pub fn has_createRequest(&self) -> bool {
        match self.req {
            ::std::option::Option::Some(FFIRequest_oneof_req::createRequest(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_createRequest(&mut self, v: SGXVMCreateRequest) {
        self.req = ::std::option::Option::Some(FFIRequest_oneof_req::createRequest(v))
    }

    // Mutable pointer to the field.
    pub fn mut_createRequest(&mut self) -> &mut SGXVMCreateRequest {
        if let ::std::option::Option::Some(FFIRequest_oneof_req::createRequest(_)) = self.req {
        } else {
            self.req = ::std::option::Option::Some(FFIRequest_oneof_req::createRequest(SGXVMCreateRequest::new()));
        }
        match self.req {
            ::std::option::Option::Some(FFIRequest_oneof_req::createRequest(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_createRequest(&mut self) -> SGXVMCreateRequest {
        if self.has_createRequest() {
            match self.req.take() {
                ::std::option::Option::Some(FFIRequest_oneof_req::createRequest(v)) => v,
                _ => panic!(),
            }
        } else {
            SGXVMCreateRequest::new()
        }
    }

    // .ffi.ffi.NodePublicKeyRequest publicKeyRequest = 3;


    pub fn get_publicKeyRequest(&self) -> &NodePublicKeyRequest {
        match self.req {
            ::std::option::Option::Some(FFIRequest_oneof_req::publicKeyRequest(ref v)) => v,
            _ => NodePublicKeyRequest::default_instance(),
        }
    }
    pub fn clear_publicKeyRequest(&mut self) {
        self.req = ::std::option::Option::None;
    }

    pub fn has_publicKeyRequest(&self) -> bool {
        match self.req {
            ::std::option::Option::Some(FFIRequest_oneof_req::publicKeyRequest(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_publicKeyRequest(&mut self, v: NodePublicKeyRequest) {
        self.req = ::std::option::Option::Some(FFIRequest_oneof_req::publicKeyRequest(v))
    }

    // Mutable pointer to the field.
    pub fn mut_publicKeyRequest(&mut self) -> &mut NodePublicKeyRequest {
        if let ::std::option::Option::Some(FFIRequest_oneof_req::publicKeyRequest(_)) = self.req {
        } else {
            self.req = ::std::option::Option::Some(FFIRequest_oneof_req::publicKeyRequest(NodePublicKeyRequest::new()));
        }
        match self.req {
            ::std::option::Option::Some(FFIRequest_oneof_req::publicKeyRequest(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_publicKeyRequest(&mut self) -> NodePublicKeyRequest {
        if self.has_publicKeyRequest() {
            match self.req.take() {
                ::std::option::Option::Some(FFIRequest_oneof_req::publicKeyRequest(v)) => v,
                _ => panic!(),
            }
        } else {
            NodePublicKeyRequest::new()
        }
    }
}

impl ::protobuf::Message for FFIRequest {
    fn is_initialized(&self) -> bool {
        if let Some(FFIRequest_oneof_req::callRequest(ref v)) = self.req {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(FFIRequest_oneof_req::createRequest(ref v)) = self.req {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(FFIRequest_oneof_req::publicKeyRequest(ref v)) = self.req {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.req = ::std::option::Option::Some(FFIRequest_oneof_req::callRequest(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.req = ::std::option::Option::Some(FFIRequest_oneof_req::createRequest(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.req = ::std::option::Option::Some(FFIRequest_oneof_req::publicKeyRequest(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.req {
            match v {
                &FFIRequest_oneof_req::callRequest(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &FFIRequest_oneof_req::createRequest(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &FFIRequest_oneof_req::publicKeyRequest(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.req {
            match v {
                &FFIRequest_oneof_req::callRequest(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &FFIRequest_oneof_req::createRequest(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &FFIRequest_oneof_req::publicKeyRequest(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FFIRequest {
        FFIRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, SGXVMCallRequest>(
                    "callRequest",
                    FFIRequest::has_callRequest,
                    FFIRequest::get_callRequest,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, SGXVMCreateRequest>(
                    "createRequest",
                    FFIRequest::has_createRequest,
                    FFIRequest::get_createRequest,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, NodePublicKeyRequest>(
                    "publicKeyRequest",
                    FFIRequest::has_publicKeyRequest,
                    FFIRequest::get_publicKeyRequest,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<FFIRequest>(
                    "FFIRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static FFIRequest {
        static mut instance: ::protobuf::lazy::Lazy<FFIRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const FFIRequest,
        };
        unsafe {
            instance.get(FFIRequest::new)
        }
    }
}

impl ::protobuf::Clear for FFIRequest {
    fn clear(&mut self) {
        self.req = ::std::option::Option::None;
        self.req = ::std::option::Option::None;
        self.req = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FFIRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FFIRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x0fproto/ffi.proto\x12\x07ffi.ffi\"L\n\x0eAccessListItem\x12\x20\n\
    \x0bstorageSlot\x18\x01\x20\x03(\x0cR\x0bstorageSlot\x12\x18\n\x07addres\
    s\x18\x02\x20\x01(\x0cR\x07address\"\xb4\x01\n\x0fTransactionData\x12\
    \x12\n\x04from\x18\x01\x20\x01(\x0cR\x04from\x12\x0e\n\x02to\x18\x02\x20\
    \x01(\x0cR\x02to\x12\x12\n\x04data\x18\x03\x20\x01(\x0cR\x04data\x12\x1a\
    \n\x08gasLimit\x18\x04\x20\x01(\x04R\x08gasLimit\x12\x14\n\x05value\x18\
    \x05\x20\x01(\x0cR\x05value\x127\n\naccessList\x18\x06\x20\x03(\x0b2\x17\
    .ffi.ffi.AccessListItemR\naccessList\"\x90\x02\n\x12TransactionContext\
    \x12\x19\n\x08chain_id\x18\x01\x20\x01(\x04R\x07chainId\x12\x1b\n\tgas_p\
    rice\x18\x02\x20\x01(\x0cR\x08gasPrice\x12\x1c\n\ttimestamp\x18\x03\x20\
    \x01(\x04R\ttimestamp\x12&\n\x0fblock_gas_limit\x18\x04\x20\x01(\x04R\rb\
    lockGasLimit\x122\n\x16block_base_fee_per_gas\x18\x05\x20\x01(\x0cR\x12b\
    lockBaseFeePerGas\x12%\n\x0eblock_coinbase\x18\x06\x20\x01(\x0cR\rblockC\
    oinbase\x12!\n\x0cblock_number\x18\x07\x20\x01(\x04R\x0bblockNumber\"\
    \x89\x01\n\x18HandleTransactionRequest\x121\n\x07tx_data\x18\x01\x20\x01\
    (\x0b2\x18.ffi.ffi.TransactionDataR\x06txData\x12:\n\ntx_context\x18\x02\
    \x20\x01(\x0b2\x1b.ffi.ffi.TransactionContextR\ttxContext\"\x85\x01\n\
    \x19HandleTransactionResponse\x12\x20\n\x04logs\x18\x02\x20\x03(\x0b2\
    \x0c.ffi.ffi.LogR\x04logs\x12\x10\n\x03ret\x18\x03\x20\x01(\x0cR\x03ret\
    \x12\x19\n\x08vm_error\x18\x04\x20\x01(\tR\x07vmError\x12\x19\n\x08gas_u\
    sed\x18\x05\x20\x01(\x04R\x07gasUsed\"\x1d\n\x05Topic\x12\x14\n\x05inner\
    \x18\x01\x20\x01(\x0cR\x05inner\"[\n\x03Log\x12\x18\n\x07address\x18\x01\
    \x20\x01(\x0cR\x07address\x12&\n\x06topics\x18\x02\x20\x03(\x0b2\x0e.ffi\
    .ffi.TopicR\x06topics\x12\x12\n\x04data\x18\x03\x20\x01(\x0cR\x04data\"+\
    \n\x0fQueryGetAccount\x12\x18\n\x07address\x18\x01\x20\x01(\x0cR\x07addr\
    ess\"I\n\x17QueryGetAccountResponse\x12\x18\n\x07balance\x18\x01\x20\x01\
    (\x0cR\x07balance\x12\x14\n\x05nonce\x18\x02\x20\x01(\x04R\x05nonce\"^\n\
    \x12QueryInsertAccount\x12\x18\n\x07address\x18\x01\x20\x01(\x0cR\x07add\
    ress\x12\x18\n\x07balance\x18\x02\x20\x01(\x0cR\x07balance\x12\x14\n\x05\
    nonce\x18\x03\x20\x01(\x04R\x05nonce\"\x1c\n\x1aQueryInsertAccountRespon\
    se\"$\n\x10QueryContainsKey\x12\x10\n\x03key\x18\x01\x20\x01(\x0cR\x03ke\
    y\"6\n\x18QueryContainsKeyResponse\x12\x1a\n\x08contains\x18\x01\x20\x01\
    (\x08R\x08contains\"L\n\x1aQueryGetAccountStorageCell\x12\x18\n\x07addre\
    ss\x18\x01\x20\x01(\x0cR\x07address\x12\x14\n\x05index\x18\x02\x20\x01(\
    \x0cR\x05index\":\n\"QueryGetAccountStorageCellResponse\x12\x14\n\x05val\
    ue\x18\x01\x20\x01(\x0cR\x05value\"/\n\x13QueryGetAccountCode\x12\x18\n\
    \x07address\x18\x01\x20\x01(\x0cR\x07address\"1\n\x1bQueryGetAccountCode\
    Response\x12\x12\n\x04code\x18\x01\x20\x01(\x0cR\x04code\"F\n\x16QueryIn\
    sertAccountCode\x12\x18\n\x07address\x18\x01\x20\x01(\x0cR\x07address\
    \x12\x12\n\x04code\x18\x02\x20\x01(\x0cR\x04code\"\x20\n\x1eQueryInsertA\
    ccountCodeResponse\"^\n\x16QueryInsertStorageCell\x12\x18\n\x07address\
    \x18\x01\x20\x01(\x0cR\x07address\x12\x14\n\x05index\x18\x02\x20\x01(\
    \x0cR\x05index\x12\x14\n\x05value\x18\x03\x20\x01(\x0cR\x05value\"\x20\n\
    \x1eQueryInsertStorageCellResponse\"'\n\x0bQueryRemove\x12\x18\n\x07addr\
    ess\x18\x01\x20\x01(\x0cR\x07address\"\x15\n\x13QueryRemoveResponse\"H\n\
    \x16QueryRemoveStorageCell\x12\x18\n\x07address\x18\x01\x20\x01(\x0cR\
    \x07address\x12\x14\n\x05index\x18\x02\x20\x01(\x0cR\x05index\"\x20\n\
    \x1eQueryRemoveStorageCellResponse\".\n\x12QueryRemoveStorage\x12\x18\n\
    \x07address\x18\x01\x20\x01(\x0cR\x07address\"\x1c\n\x1aQueryRemoveStora\
    geResponse\"(\n\x0eQueryBlockHash\x12\x16\n\x06number\x18\x01\x20\x01(\
    \x0cR\x06number\",\n\x16QueryBlockHashResponse\x12\x12\n\x04hash\x18\x01\
    \x20\x01(\x0cR\x04hash\"\x97\x03\n\x1bQueryAddVerificationDetails\x12\
    \x20\n\x0buserAddress\x18\x01\x20\x01(\x0cR\x0buserAddress\x12$\n\rissue\
    rAddress\x18\x02\x20\x01(\x0cR\rissuerAddress\x12\x20\n\x0boriginChain\
    \x18\x03\x20\x01(\tR\x0boriginChain\x12*\n\x10verificationType\x18\x04\
    \x20\x01(\rR\x10verificationType\x12,\n\x11issuanceTimestamp\x18\x05\x20\
    \x01(\rR\x11issuanceTimestamp\x120\n\x13expirationTimestamp\x18\x06\x20\
    \x01(\rR\x13expirationTimestamp\x12\x1c\n\tproofData\x18\x07\x20\x01(\
    \x0cR\tproofData\x12\x16\n\x06schema\x18\x08\x20\x01(\tR\x06schema\x122\
    \n\x14issuerVerificationId\x18\t\x20\x01(\tR\x14issuerVerificationId\x12\
    \x18\n\x07version\x18\n\x20\x01(\rR\x07version\"M\n#QueryAddVerification\
    DetailsResponse\x12&\n\x0everificationId\x18\x01\x20\x01(\x0cR\x0everifi\
    cationId\"\xbe\x01\n\x14QueryHasVerification\x12\x20\n\x0buserAddress\
    \x18\x01\x20\x01(\x0cR\x0buserAddress\x12*\n\x10verificationType\x18\x02\
    \x20\x01(\rR\x10verificationType\x120\n\x13expirationTimestamp\x18\x03\
    \x20\x01(\rR\x13expirationTimestamp\x12&\n\x0eallowedIssuers\x18\x04\x20\
    \x03(\x0cR\x0eallowedIssuers\"H\n\x1cQueryHasVerificationResponse\x12(\n\
    \x0fhasVerification\x18\x01\x20\x01(\x08R\x0fhasVerification\"b\n\x18Que\
    ryGetVerificationData\x12\x20\n\x0buserAddress\x18\x01\x20\x01(\x0cR\x0b\
    userAddress\x12$\n\rissuerAddress\x18\x02\x20\x01(\x0cR\rissuerAddress\"\
    \x9b\x03\n\x13VerificationDetails\x12*\n\x10verificationType\x18\x01\x20\
    \x01(\rR\x10verificationType\x12&\n\x0everificationID\x18\x02\x20\x01(\
    \x0cR\x0everificationID\x12$\n\rissuerAddress\x18\x03\x20\x01(\x0cR\riss\
    uerAddress\x12\x20\n\x0boriginChain\x18\x04\x20\x01(\tR\x0boriginChain\
    \x12,\n\x11issuanceTimestamp\x18\x05\x20\x01(\rR\x11issuanceTimestamp\
    \x120\n\x13expirationTimestamp\x18\x06\x20\x01(\rR\x13expirationTimestam\
    p\x12\"\n\x0coriginalData\x18\x07\x20\x01(\x0cR\x0coriginalData\x12\x16\
    \n\x06schema\x18\x08\x20\x01(\tR\x06schema\x122\n\x14issuerVerificationI\
    d\x18\t\x20\x01(\tR\x14issuerVerificationId\x12\x18\n\x07version\x18\n\
    \x20\x01(\rR\x07version\"T\n\x20QueryGetVerificationDataResponse\x120\n\
    \x04data\x18\x01\x20\x03(\x0b2\x1c.ffi.ffi.VerificationDetailsR\x04data\
    \"\x84\x08\n\rCosmosRequest\x12:\n\ngetAccount\x18\x01\x20\x01(\x0b2\x18\
    .ffi.ffi.QueryGetAccountH\0R\ngetAccount\x12C\n\rinsertAccount\x18\x02\
    \x20\x01(\x0b2\x1b.ffi.ffi.QueryInsertAccountH\0R\rinsertAccount\x12=\n\
    \x0bcontainsKey\x18\x03\x20\x01(\x0b2\x19.ffi.ffi.QueryContainsKeyH\0R\
    \x0bcontainsKey\x12@\n\x0baccountCode\x18\x04\x20\x01(\x0b2\x1c.ffi.ffi.\
    QueryGetAccountCodeH\0R\x0baccountCode\x12G\n\x0bstorageCell\x18\x05\x20\
    \x01(\x0b2#.ffi.ffi.QueryGetAccountStorageCellH\0R\x0bstorageCell\x12O\n\
    \x11insertAccountCode\x18\x06\x20\x01(\x0b2\x1f.ffi.ffi.QueryInsertAccou\
    ntCodeH\0R\x11insertAccountCode\x12O\n\x11insertStorageCell\x18\x07\x20\
    \x01(\x0b2\x1f.ffi.ffi.QueryInsertStorageCellH\0R\x11insertStorageCell\
    \x12.\n\x06remove\x18\x08\x20\x01(\x0b2\x14.ffi.ffi.QueryRemoveH\0R\x06r\
    emove\x12O\n\x11removeStorageCell\x18\t\x20\x01(\x0b2\x1f.ffi.ffi.QueryR\
    emoveStorageCellH\0R\x11removeStorageCell\x12C\n\rremoveStorage\x18\n\
    \x20\x01(\x0b2\x1b.ffi.ffi.QueryRemoveStorageH\0R\rremoveStorage\x127\n\
    \tblockHash\x18\x0b\x20\x01(\x0b2\x17.ffi.ffi.QueryBlockHashH\0R\tblockH\
    ash\x12^\n\x16addVerificationDetails\x18\x0c\x20\x01(\x0b2$.ffi.ffi.Quer\
    yAddVerificationDetailsH\0R\x16addVerificationDetails\x12I\n\x0fhasVerif\
    ication\x18\r\x20\x01(\x0b2\x1d.ffi.ffi.QueryHasVerificationH\0R\x0fhasV\
    erification\x12U\n\x13getVerificationData\x18\x0e\x20\x01(\x0b2!.ffi.ffi\
    .QueryGetVerificationDataH\0R\x13getVerificationDataB\x05\n\x03req\"\xe2\
    \x01\n\x0fSGXVMCallParams\x12\x12\n\x04from\x18\x01\x20\x01(\x0cR\x04fro\
    m\x12\x0e\n\x02to\x18\x02\x20\x01(\x0cR\x02to\x12\x12\n\x04data\x18\x03\
    \x20\x01(\x0cR\x04data\x12\x1a\n\x08gasLimit\x18\x04\x20\x01(\x04R\x08ga\
    sLimit\x12\x14\n\x05value\x18\x05\x20\x01(\x0cR\x05value\x127\n\naccessL\
    ist\x18\x06\x20\x03(\x0b2\x17.ffi.ffi.AccessListItemR\naccessList\x12\
    \x16\n\x06commit\x18\x07\x20\x01(\x08R\x06commit\x12\x14\n\x05nonce\x18\
    \x08\x20\x01(\x04R\x05nonce\"\xd4\x01\n\x11SGXVMCreateParams\x12\x12\n\
    \x04from\x18\x01\x20\x01(\x0cR\x04from\x12\x12\n\x04data\x18\x02\x20\x01\
    (\x0cR\x04data\x12\x1a\n\x08gasLimit\x18\x03\x20\x01(\x04R\x08gasLimit\
    \x12\x14\n\x05value\x18\x04\x20\x01(\x0cR\x05value\x127\n\naccessList\
    \x18\x05\x20\x03(\x0b2\x17.ffi.ffi.AccessListItemR\naccessList\x12\x16\n\
    \x06commit\x18\x06\x20\x01(\x08R\x06commit\x12\x14\n\x05nonce\x18\x07\
    \x20\x01(\x04R\x05nonce\"{\n\x10SGXVMCallRequest\x120\n\x06params\x18\
    \x01\x20\x01(\x0b2\x18.ffi.ffi.SGXVMCallParamsR\x06params\x125\n\x07cont\
    ext\x18\x02\x20\x01(\x0b2\x1b.ffi.ffi.TransactionContextR\x07context\"\
    \x7f\n\x12SGXVMCreateRequest\x122\n\x06params\x18\x01\x20\x01(\x0b2\x1a.\
    ffi.ffi.SGXVMCreateParamsR\x06params\x125\n\x07context\x18\x02\x20\x01(\
    \x0b2\x1b.ffi.ffi.TransactionContextR\x07context\"8\n\x14NodePublicKeyRe\
    quest\x12\x20\n\x0bblockNumber\x18\x01\x20\x01(\x04R\x0bblockNumber\"5\n\
    \x15NodePublicKeyResponse\x12\x1c\n\tpublicKey\x18\x01\x20\x01(\x0cR\tpu\
    blicKey\"y\n\tEpochData\x12\x20\n\x0bepochNumber\x18\x01\x20\x01(\rR\x0b\
    epochNumber\x12$\n\rstartingBlock\x18\x02\x20\x01(\x04R\rstartingBlock\
    \x12$\n\rnodePublicKey\x18\x03\x20\x01(\x0cR\rnodePublicKey\"@\n\x12List\
    EpochsResponse\x12*\n\x06epochs\x18\x01\x20\x03(\x0b2\x12.ffi.ffi.EpochD\
    ataR\x06epochs\"\xe4\x01\n\nFFIRequest\x12=\n\x0bcallRequest\x18\x01\x20\
    \x01(\x0b2\x19.ffi.ffi.SGXVMCallRequestH\0R\x0bcallRequest\x12C\n\rcreat\
    eRequest\x18\x02\x20\x01(\x0b2\x1b.ffi.ffi.SGXVMCreateRequestH\0R\rcreat\
    eRequest\x12K\n\x10publicKeyRequest\x18\x03\x20\x01(\x0b2\x1d.ffi.ffi.No\
    dePublicKeyRequestH\0R\x10publicKeyRequestB\x05\n\x03reqB&Z$github.com/S\
    igmaGmbH/librustgo/typesJ\xb6N\n\x07\x12\x05\0\0\x92\x02\x01\n\x08\n\x01\
    \x0c\x12\x03\0\0\x12\n\x08\n\x01\x02\x12\x03\x02\0\x10\n\x08\n\x01\x08\
    \x12\x03\x04\0;\n\t\n\x02\x08\x0b\x12\x03\x04\0;\n\x1d\n\x02\x04\0\x12\
    \x04\x08\0\x0b\x012\x11\x20General\x20request\n\n\n\n\x03\x04\0\x01\x12\
    \x03\x08\x08\x16\n\x0b\n\x04\x04\0\x02\0\x12\x03\t\x02!\n\x0c\n\x05\x04\
    \0\x02\0\x04\x12\x03\t\x02\n\n\x0c\n\x05\x04\0\x02\0\x05\x12\x03\t\x0b\
    \x10\n\x0c\n\x05\x04\0\x02\0\x01\x12\x03\t\x11\x1c\n\x0c\n\x05\x04\0\x02\
    \0\x03\x12\x03\t\x1f\x20\n\x0b\n\x04\x04\0\x02\x01\x12\x03\n\x02\x14\n\
    \x0c\n\x05\x04\0\x02\x01\x05\x12\x03\n\x02\x07\n\x0c\n\x05\x04\0\x02\x01\
    \x01\x12\x03\n\x08\x0f\n\x0c\n\x05\x04\0\x02\x01\x03\x12\x03\n\x12\x13\n\
    \n\n\x02\x04\x01\x12\x04\r\0\x14\x01\n\n\n\x03\x04\x01\x01\x12\x03\r\x08\
    \x17\n\x0b\n\x04\x04\x01\x02\0\x12\x03\x0e\x02\x11\n\x0c\n\x05\x04\x01\
    \x02\0\x05\x12\x03\x0e\x02\x07\n\x0c\n\x05\x04\x01\x02\0\x01\x12\x03\x0e\
    \x08\x0c\n\x0c\n\x05\x04\x01\x02\0\x03\x12\x03\x0e\x0f\x10\n\x0b\n\x04\
    \x04\x01\x02\x01\x12\x03\x0f\x02\x0f\n\x0c\n\x05\x04\x01\x02\x01\x05\x12\
    \x03\x0f\x02\x07\n\x0c\n\x05\x04\x01\x02\x01\x01\x12\x03\x0f\x08\n\n\x0c\
    \n\x05\x04\x01\x02\x01\x03\x12\x03\x0f\r\x0e\n\x0b\n\x04\x04\x01\x02\x02\
    \x12\x03\x10\x02\x11\n\x0c\n\x05\x04\x01\x02\x02\x05\x12\x03\x10\x02\x07\
    \n\x0c\n\x05\x04\x01\x02\x02\x01\x12\x03\x10\x08\x0c\n\x0c\n\x05\x04\x01\
    \x02\x02\x03\x12\x03\x10\x0f\x10\n\x0b\n\x04\x04\x01\x02\x03\x12\x03\x11\
    \x02\x16\n\x0c\n\x05\x04\x01\x02\x03\x05\x12\x03\x11\x02\x08\n\x0c\n\x05\
    \x04\x01\x02\x03\x01\x12\x03\x11\t\x11\n\x0c\n\x05\x04\x01\x02\x03\x03\
    \x12\x03\x11\x14\x15\n\x0b\n\x04\x04\x01\x02\x04\x12\x03\x12\x02\x12\n\
    \x0c\n\x05\x04\x01\x02\x04\x05\x12\x03\x12\x02\x07\n\x0c\n\x05\x04\x01\
    \x02\x04\x01\x12\x03\x12\x08\r\n\x0c\n\x05\x04\x01\x02\x04\x03\x12\x03\
    \x12\x10\x11\n\x0b\n\x04\x04\x01\x02\x05\x12\x03\x13\x02)\n\x0c\n\x05\
    \x04\x01\x02\x05\x04\x12\x03\x13\x02\n\n\x0c\n\x05\x04\x01\x02\x05\x06\
    \x12\x03\x13\x0b\x19\n\x0c\n\x05\x04\x01\x02\x05\x01\x12\x03\x13\x1a$\n\
    \x0c\n\x05\x04\x01\x02\x05\x03\x12\x03\x13'(\n\n\n\x02\x04\x02\x12\x04\
    \x16\0\x1e\x01\n\n\n\x03\x04\x02\x01\x12\x03\x16\x08\x1a\n\x0b\n\x04\x04\
    \x02\x02\0\x12\x03\x17\x02\x16\n\x0c\n\x05\x04\x02\x02\0\x05\x12\x03\x17\
    \x02\x08\n\x0c\n\x05\x04\x02\x02\0\x01\x12\x03\x17\t\x11\n\x0c\n\x05\x04\
    \x02\x02\0\x03\x12\x03\x17\x14\x15\n\x0b\n\x04\x04\x02\x02\x01\x12\x03\
    \x18\x02\x16\n\x0c\n\x05\x04\x02\x02\x01\x05\x12\x03\x18\x02\x07\n\x0c\n\
    \x05\x04\x02\x02\x01\x01\x12\x03\x18\x08\x11\n\x0c\n\x05\x04\x02\x02\x01\
    \x03\x12\x03\x18\x14\x15\n\x0b\n\x04\x04\x02\x02\x02\x12\x03\x19\x02\x17\
    \n\x0c\n\x05\x04\x02\x02\x02\x05\x12\x03\x19\x02\x08\n\x0c\n\x05\x04\x02\
    \x02\x02\x01\x12\x03\x19\t\x12\n\x0c\n\x05\x04\x02\x02\x02\x03\x12\x03\
    \x19\x15\x16\n\x0b\n\x04\x04\x02\x02\x03\x12\x03\x1a\x02\x1d\n\x0c\n\x05\
    \x04\x02\x02\x03\x05\x12\x03\x1a\x02\x08\n\x0c\n\x05\x04\x02\x02\x03\x01\
    \x12\x03\x1a\t\x18\n\x0c\n\x05\x04\x02\x02\x03\x03\x12\x03\x1a\x1b\x1c\n\
    \x0b\n\x04\x04\x02\x02\x04\x12\x03\x1b\x02#\n\x0c\n\x05\x04\x02\x02\x04\
    \x05\x12\x03\x1b\x02\x07\n\x0c\n\x05\x04\x02\x02\x04\x01\x12\x03\x1b\x08\
    \x1e\n\x0c\n\x05\x04\x02\x02\x04\x03\x12\x03\x1b!\"\n\x0b\n\x04\x04\x02\
    \x02\x05\x12\x03\x1c\x02\x1b\n\x0c\n\x05\x04\x02\x02\x05\x05\x12\x03\x1c\
    \x02\x07\n\x0c\n\x05\x04\x02\x02\x05\x01\x12\x03\x1c\x08\x16\n\x0c\n\x05\
    \x04\x02\x02\x05\x03\x12\x03\x1c\x19\x1a\n\x0b\n\x04\x04\x02\x02\x06\x12\
    \x03\x1d\x02\x1a\n\x0c\n\x05\x04\x02\x02\x06\x05\x12\x03\x1d\x02\x08\n\
    \x0c\n\x05\x04\x02\x02\x06\x01\x12\x03\x1d\t\x15\n\x0c\n\x05\x04\x02\x02\
    \x06\x03\x12\x03\x1d\x18\x19\n\n\n\x02\x04\x03\x12\x04\x20\0#\x01\n\n\n\
    \x03\x04\x03\x01\x12\x03\x20\x08\x20\n\x0b\n\x04\x04\x03\x02\0\x12\x03!\
    \x02\x1e\n\x0c\n\x05\x04\x03\x02\0\x06\x12\x03!\x02\x11\n\x0c\n\x05\x04\
    \x03\x02\0\x01\x12\x03!\x12\x19\n\x0c\n\x05\x04\x03\x02\0\x03\x12\x03!\
    \x1c\x1d\n\x0b\n\x04\x04\x03\x02\x01\x12\x03\"\x02$\n\x0c\n\x05\x04\x03\
    \x02\x01\x06\x12\x03\"\x02\x14\n\x0c\n\x05\x04\x03\x02\x01\x01\x12\x03\"\
    \x15\x1f\n\x0c\n\x05\x04\x03\x02\x01\x03\x12\x03\"\"#\n\n\n\x02\x04\x04\
    \x12\x04%\00\x01\n\n\n\x03\x04\x04\x01\x12\x03%\x08!\nZ\n\x04\x04\x04\
    \x02\0\x12\x03(\x02\x18\x1aM\x20logs\x20contains\x20the\x20transaction\
    \x20hash\x20and\x20the\x20proto-compatible\x20ethereum\n\x20logs.\n\n\
    \x0c\n\x05\x04\x04\x02\0\x04\x12\x03(\x02\n\n\x0c\n\x05\x04\x04\x02\0\
    \x06\x12\x03(\x0b\x0e\n\x0c\n\x05\x04\x04\x02\0\x01\x12\x03(\x0f\x13\n\
    \x0c\n\x05\x04\x04\x02\0\x03\x12\x03(\x16\x17\n\\\n\x04\x04\x04\x02\x01\
    \x12\x03+\x02\x10\x1aO\x20returned\x20data\x20from\x20evm\x20function\
    \x20(result\x20or\x20data\x20supplied\x20with\x20revert\n\x20opcode)\n\n\
    \x0c\n\x05\x04\x04\x02\x01\x05\x12\x03+\x02\x07\n\x0c\n\x05\x04\x04\x02\
    \x01\x01\x12\x03+\x08\x0b\n\x0c\n\x05\x04\x04\x02\x01\x03\x12\x03+\x0e\
    \x0f\n=\n\x04\x04\x04\x02\x02\x12\x03-\x02\x16\x1a0\x20vm\x20error\x20is\
    \x20the\x20error\x20returned\x20by\x20vm\x20execution\n\n\x0c\n\x05\x04\
    \x04\x02\x02\x05\x12\x03-\x02\x08\n\x0c\n\x05\x04\x04\x02\x02\x01\x12\
    \x03-\t\x11\n\x0c\n\x05\x04\x04\x02\x02\x03\x12\x03-\x14\x15\n.\n\x04\
    \x04\x04\x02\x03\x12\x03/\x02\x16\x1a!\x20gas\x20consumed\x20by\x20the\
    \x20transaction\n\n\x0c\n\x05\x04\x04\x02\x03\x05\x12\x03/\x02\x08\n\x0c\
    \n\x05\x04\x04\x02\x03\x01\x12\x03/\t\x11\n\x0c\n\x05\x04\x04\x02\x03\
    \x03\x12\x03/\x14\x15\nc\n\x02\x04\x05\x12\x034\0\"\x1aX\x20Topic\x20rep\
    resents\x2032-byte\x20words\x20that\x20is\x20used\x20to\x20describe\x20w\
    hat\xe2\x80\x99s\x20going\x20on\x20in\x20an\n\x20event\n\n\n\n\x03\x04\
    \x05\x01\x12\x034\x08\r\n\x0b\n\x04\x04\x05\x02\0\x12\x034\x10\x20\n\x0c\
    \n\x05\x04\x05\x02\0\x05\x12\x034\x10\x15\n\x0c\n\x05\x04\x05\x02\0\x01\
    \x12\x034\x16\x1b\n\x0c\n\x05\x04\x05\x02\0\x03\x12\x034\x1e\x1f\n\x81\
    \x01\n\x02\x04\x06\x12\x049\0@\x01\x1au\x20Log\x20represents\x20an\x20pr\
    otobuf\x20compatible\x20Ethereum\x20Log\x20that\x20defines\x20a\x20contr\
    act\n\x20log\x20event.\n\x20Copied\x20from\x20`devnet/proto``\n\n\n\n\
    \x03\x04\x06\x01\x12\x039\x08\x0b\n?\n\x04\x04\x06\x02\0\x12\x03;\x02\
    \x14\x1a2\x20address\x20of\x20the\x20contract\x20that\x20generated\x20th\
    e\x20event\n\n\x0c\n\x05\x04\x06\x02\0\x05\x12\x03;\x02\x07\n\x0c\n\x05\
    \x04\x06\x02\0\x01\x12\x03;\x08\x0f\n\x0c\n\x05\x04\x06\x02\0\x03\x12\
    \x03;\x12\x13\n7\n\x04\x04\x06\x02\x01\x12\x03=\x02\x1c\x1a*\x20list\x20\
    of\x20topics\x20provided\x20by\x20the\x20contract.\n\n\x0c\n\x05\x04\x06\
    \x02\x01\x04\x12\x03=\x02\n\n\x0c\n\x05\x04\x06\x02\x01\x06\x12\x03=\x0b\
    \x10\n\x0c\n\x05\x04\x06\x02\x01\x01\x12\x03=\x11\x17\n\x0c\n\x05\x04\
    \x06\x02\x01\x03\x12\x03=\x1a\x1b\n<\n\x04\x04\x06\x02\x02\x12\x03?\x02\
    \x11\x1a/\x20supplied\x20by\x20the\x20contract,\x20usually\x20ABI-encode\
    d\n\n\x0c\n\x05\x04\x06\x02\x02\x05\x12\x03?\x02\x07\n\x0c\n\x05\x04\x06\
    \x02\x02\x01\x12\x03?\x08\x0c\n\x0c\n\x05\x04\x06\x02\x02\x03\x12\x03?\
    \x0f\x10\nX\n\x02\x04\x07\x12\x04C\0F\x01\x1aL\x20Request\x20for\x20acco\
    unt\x20code\x20(smart\x20contract\x20deployed\x20behind\x20provided\x20a\
    ddress)\n\n\n\n\x03\x04\x07\x01\x12\x03C\x08\x17\n*\n\x04\x04\x07\x02\0\
    \x12\x03E\x02\x14\x1a\x1d\x2020\x20bytes\x20of\x20account\x20address\n\n\
    \x0c\n\x05\x04\x07\x02\0\x05\x12\x03E\x02\x07\n\x0c\n\x05\x04\x07\x02\0\
    \x01\x12\x03E\x08\x0f\n\x0c\n\x05\x04\x07\x02\0\x03\x12\x03E\x12\x13\n'\
    \n\x02\x04\x08\x12\x04I\0N\x01\x1a\x1b\x20Response\x20for\x20account\x20\
    code\n\n\n\n\x03\x04\x08\x01\x12\x03I\x08\x1f\nb\n\x04\x04\x08\x02\0\x12\
    \x03L\x02\x14\x1aU\x20Since\x20both\x20fields\x20are\x20256-bit\x20unsig\
    ned\x20integer,\x20we\x20encode\x20them\x20as\n\x20big-endian\x20bytes\n\
    \n\x0c\n\x05\x04\x08\x02\0\x05\x12\x03L\x02\x07\n\x0c\n\x05\x04\x08\x02\
    \0\x01\x12\x03L\x08\x0f\n\x0c\n\x05\x04\x08\x02\0\x03\x12\x03L\x12\x13\n\
    \x0b\n\x04\x04\x08\x02\x01\x12\x03M\x02\x13\n\x0c\n\x05\x04\x08\x02\x01\
    \x05\x12\x03M\x02\x08\n\x0c\n\x05\x04\x08\x02\x01\x01\x12\x03M\t\x0e\n\
    \x0c\n\x05\x04\x08\x02\x01\x03\x12\x03M\x11\x12\nF\n\x02\x04\t\x12\x04Q\
    \0U\x01\x1a:\x20Request\x20to\x20insert\x20account\x20data\x20such\x20as\
    \x20balance\x20and\x20nonce\n\n\n\n\x03\x04\t\x01\x12\x03Q\x08\x1a\n\x0b\
    \n\x04\x04\t\x02\0\x12\x03R\x02\x14\n\x0c\n\x05\x04\t\x02\0\x05\x12\x03R\
    \x02\x07\n\x0c\n\x05\x04\t\x02\0\x01\x12\x03R\x08\x0f\n\x0c\n\x05\x04\t\
    \x02\0\x03\x12\x03R\x12\x13\n\x0b\n\x04\x04\t\x02\x01\x12\x03S\x02\x14\n\
    \x0c\n\x05\x04\t\x02\x01\x05\x12\x03S\x02\x07\n\x0c\n\x05\x04\t\x02\x01\
    \x01\x12\x03S\x08\x0f\n\x0c\n\x05\x04\t\x02\x01\x03\x12\x03S\x12\x13\n\
    \x0b\n\x04\x04\t\x02\x02\x12\x03T\x02\x13\n\x0c\n\x05\x04\t\x02\x02\x05\
    \x12\x03T\x02\x08\n\x0c\n\x05\x04\t\x02\x02\x01\x12\x03T\t\x0e\n\x0c\n\
    \x05\x04\t\x02\x02\x03\x12\x03T\x11\x12\n+\n\x02\x04\n\x12\x03X\0%\x1a\
    \x20\x20Response\x20for\x20account\x20insertion\n\n\n\n\x03\x04\n\x01\
    \x12\x03X\x08\"\n\t\n\x02\x04\x0b\x12\x03Z\0+\n\n\n\x03\x04\x0b\x01\x12\
    \x03Z\x08\x18\n\x0b\n\x04\x04\x0b\x02\0\x12\x03Z\x1b)\n\x0c\n\x05\x04\
    \x0b\x02\0\x05\x12\x03Z\x1b\x20\n\x0c\n\x05\x04\x0b\x02\0\x01\x12\x03Z!$\
    \n\x0c\n\x05\x04\x0b\x02\0\x03\x12\x03Z'(\n\t\n\x02\x04\x0c\x12\x03\\\07\
    \n\n\n\x03\x04\x0c\x01\x12\x03\\\x08\x20\n\x0b\n\x04\x04\x0c\x02\0\x12\
    \x03\\#5\n\x0c\n\x05\x04\x0c\x02\0\x05\x12\x03\\#'\n\x0c\n\x05\x04\x0c\
    \x02\0\x01\x12\x03\\(0\n\x0c\n\x05\x04\x0c\x02\0\x03\x12\x03\\34\n\n\n\
    \x02\x04\r\x12\x04^\0a\x01\n\n\n\x03\x04\r\x01\x12\x03^\x08\"\n\x0b\n\
    \x04\x04\r\x02\0\x12\x03_\x02\x14\n\x0c\n\x05\x04\r\x02\0\x05\x12\x03_\
    \x02\x07\n\x0c\n\x05\x04\r\x02\0\x01\x12\x03_\x08\x0f\n\x0c\n\x05\x04\r\
    \x02\0\x03\x12\x03_\x12\x13\n\x0b\n\x04\x04\r\x02\x01\x12\x03`\x02\x12\n\
    \x0c\n\x05\x04\r\x02\x01\x05\x12\x03`\x02\x07\n\x0c\n\x05\x04\r\x02\x01\
    \x01\x12\x03`\x08\r\n\x0c\n\x05\x04\r\x02\x01\x03\x12\x03`\x10\x11\n\t\n\
    \x02\x04\x0e\x12\x03c\0?\n\n\n\x03\x04\x0e\x01\x12\x03c\x08*\n\x0b\n\x04\
    \x04\x0e\x02\0\x12\x03c-=\n\x0c\n\x05\x04\x0e\x02\0\x05\x12\x03c-2\n\x0c\
    \n\x05\x04\x0e\x02\0\x01\x12\x03c38\n\x0c\n\x05\x04\x0e\x02\0\x03\x12\
    \x03c;<\n\t\n\x02\x04\x0f\x12\x03e\02\n\n\n\x03\x04\x0f\x01\x12\x03e\x08\
    \x1b\n\x0b\n\x04\x04\x0f\x02\0\x12\x03e\x1e0\n\x0c\n\x05\x04\x0f\x02\0\
    \x05\x12\x03e\x1e#\n\x0c\n\x05\x04\x0f\x02\0\x01\x12\x03e$+\n\x0c\n\x05\
    \x04\x0f\x02\0\x03\x12\x03e./\n\t\n\x02\x04\x10\x12\x03g\07\n\n\n\x03\
    \x04\x10\x01\x12\x03g\x08#\n\x0b\n\x04\x04\x10\x02\0\x12\x03g&5\n\x0c\n\
    \x05\x04\x10\x02\0\x05\x12\x03g&+\n\x0c\n\x05\x04\x10\x02\0\x01\x12\x03g\
    ,0\n\x0c\n\x05\x04\x10\x02\0\x03\x12\x03g34\n\n\n\x02\x04\x11\x12\x04i\0\
    l\x01\n\n\n\x03\x04\x11\x01\x12\x03i\x08\x1e\n\x0b\n\x04\x04\x11\x02\0\
    \x12\x03j\x02\x14\n\x0c\n\x05\x04\x11\x02\0\x05\x12\x03j\x02\x07\n\x0c\n\
    \x05\x04\x11\x02\0\x01\x12\x03j\x08\x0f\n\x0c\n\x05\x04\x11\x02\0\x03\
    \x12\x03j\x12\x13\n\x0b\n\x04\x04\x11\x02\x01\x12\x03k\x02\x11\n\x0c\n\
    \x05\x04\x11\x02\x01\x05\x12\x03k\x02\x07\n\x0c\n\x05\x04\x11\x02\x01\
    \x01\x12\x03k\x08\x0c\n\x0c\n\x05\x04\x11\x02\x01\x03\x12\x03k\x0f\x10\n\
    \t\n\x02\x04\x12\x12\x03n\0)\n\n\n\x03\x04\x12\x01\x12\x03n\x08&\n\n\n\
    \x02\x04\x13\x12\x04p\0t\x01\n\n\n\x03\x04\x13\x01\x12\x03p\x08\x1e\n\
    \x0b\n\x04\x04\x13\x02\0\x12\x03q\x02\x14\n\x0c\n\x05\x04\x13\x02\0\x05\
    \x12\x03q\x02\x07\n\x0c\n\x05\x04\x13\x02\0\x01\x12\x03q\x08\x0f\n\x0c\n\
    \x05\x04\x13\x02\0\x03\x12\x03q\x12\x13\n\x0b\n\x04\x04\x13\x02\x01\x12\
    \x03r\x02\x12\n\x0c\n\x05\x04\x13\x02\x01\x05\x12\x03r\x02\x07\n\x0c\n\
    \x05\x04\x13\x02\x01\x01\x12\x03r\x08\r\n\x0c\n\x05\x04\x13\x02\x01\x03\
    \x12\x03r\x10\x11\n\x0b\n\x04\x04\x13\x02\x02\x12\x03s\x02\x12\n\x0c\n\
    \x05\x04\x13\x02\x02\x05\x12\x03s\x02\x07\n\x0c\n\x05\x04\x13\x02\x02\
    \x01\x12\x03s\x08\r\n\x0c\n\x05\x04\x13\x02\x02\x03\x12\x03s\x10\x11\n\t\
    \n\x02\x04\x14\x12\x03v\0)\n\n\n\x03\x04\x14\x01\x12\x03v\x08&\n\t\n\x02\
    \x04\x15\x12\x03x\0*\n\n\n\x03\x04\x15\x01\x12\x03x\x08\x13\n\x0b\n\x04\
    \x04\x15\x02\0\x12\x03x\x16(\n\x0c\n\x05\x04\x15\x02\0\x05\x12\x03x\x16\
    \x1b\n\x0c\n\x05\x04\x15\x02\0\x01\x12\x03x\x1c#\n\x0c\n\x05\x04\x15\x02\
    \0\x03\x12\x03x&'\n\t\n\x02\x04\x16\x12\x03z\0\x1e\n\n\n\x03\x04\x16\x01\
    \x12\x03z\x08\x1b\n\n\n\x02\x04\x17\x12\x04|\0\x7f\x01\n\n\n\x03\x04\x17\
    \x01\x12\x03|\x08\x1e\n\x0b\n\x04\x04\x17\x02\0\x12\x03}\x02\x14\n\x0c\n\
    \x05\x04\x17\x02\0\x05\x12\x03}\x02\x07\n\x0c\n\x05\x04\x17\x02\0\x01\
    \x12\x03}\x08\x0f\n\x0c\n\x05\x04\x17\x02\0\x03\x12\x03}\x12\x13\n\x0b\n\
    \x04\x04\x17\x02\x01\x12\x03~\x02\x12\n\x0c\n\x05\x04\x17\x02\x01\x05\
    \x12\x03~\x02\x07\n\x0c\n\x05\x04\x17\x02\x01\x01\x12\x03~\x08\r\n\x0c\n\
    \x05\x04\x17\x02\x01\x03\x12\x03~\x10\x11\n\n\n\x02\x04\x18\x12\x04\x81\
    \x01\0)\n\x0b\n\x03\x04\x18\x01\x12\x04\x81\x01\x08&\n\n\n\x02\x04\x19\
    \x12\x04\x83\x01\01\n\x0b\n\x03\x04\x19\x01\x12\x04\x83\x01\x08\x1a\n\
    \x0c\n\x04\x04\x19\x02\0\x12\x04\x83\x01\x1d/\n\r\n\x05\x04\x19\x02\0\
    \x05\x12\x04\x83\x01\x1d\"\n\r\n\x05\x04\x19\x02\0\x01\x12\x04\x83\x01#*\
    \n\r\n\x05\x04\x19\x02\0\x03\x12\x04\x83\x01-.\n\n\n\x02\x04\x1a\x12\x04\
    \x85\x01\0%\n\x0b\n\x03\x04\x1a\x01\x12\x04\x85\x01\x08\"\n\n\n\x02\x04\
    \x1b\x12\x04\x87\x01\0,\n\x0b\n\x03\x04\x1b\x01\x12\x04\x87\x01\x08\x16\
    \n\x0c\n\x04\x04\x1b\x02\0\x12\x04\x87\x01\x19*\n\r\n\x05\x04\x1b\x02\0\
    \x05\x12\x04\x87\x01\x19\x1e\n\r\n\x05\x04\x1b\x02\0\x01\x12\x04\x87\x01\
    \x1f%\n\r\n\x05\x04\x1b\x02\0\x03\x12\x04\x87\x01()\n\n\n\x02\x04\x1c\
    \x12\x04\x88\x01\02\n\x0b\n\x03\x04\x1c\x01\x12\x04\x88\x01\x08\x1e\n\
    \x0c\n\x04\x04\x1c\x02\0\x12\x04\x88\x01!0\n\r\n\x05\x04\x1c\x02\0\x05\
    \x12\x04\x88\x01!&\n\r\n\x05\x04\x1c\x02\0\x01\x12\x04\x88\x01'+\n\r\n\
    \x05\x04\x1c\x02\0\x03\x12\x04\x88\x01./\n\x0c\n\x02\x04\x1d\x12\x06\x8a\
    \x01\0\x95\x01\x01\n\x0b\n\x03\x04\x1d\x01\x12\x04\x8a\x01\x08#\n\x0c\n\
    \x04\x04\x1d\x02\0\x12\x04\x8b\x01\x02\x18\n\r\n\x05\x04\x1d\x02\0\x05\
    \x12\x04\x8b\x01\x02\x07\n\r\n\x05\x04\x1d\x02\0\x01\x12\x04\x8b\x01\x08\
    \x13\n\r\n\x05\x04\x1d\x02\0\x03\x12\x04\x8b\x01\x16\x17\n\x0c\n\x04\x04\
    \x1d\x02\x01\x12\x04\x8c\x01\x02\x1a\n\r\n\x05\x04\x1d\x02\x01\x05\x12\
    \x04\x8c\x01\x02\x07\n\r\n\x05\x04\x1d\x02\x01\x01\x12\x04\x8c\x01\x08\
    \x15\n\r\n\x05\x04\x1d\x02\x01\x03\x12\x04\x8c\x01\x18\x19\n\x0c\n\x04\
    \x04\x1d\x02\x02\x12\x04\x8d\x01\x02\x19\n\r\n\x05\x04\x1d\x02\x02\x05\
    \x12\x04\x8d\x01\x02\x08\n\r\n\x05\x04\x1d\x02\x02\x01\x12\x04\x8d\x01\t\
    \x14\n\r\n\x05\x04\x1d\x02\x02\x03\x12\x04\x8d\x01\x17\x18\n\x0c\n\x04\
    \x04\x1d\x02\x03\x12\x04\x8e\x01\x02\x1e\n\r\n\x05\x04\x1d\x02\x03\x05\
    \x12\x04\x8e\x01\x02\x08\n\r\n\x05\x04\x1d\x02\x03\x01\x12\x04\x8e\x01\t\
    \x19\n\r\n\x05\x04\x1d\x02\x03\x03\x12\x04\x8e\x01\x1c\x1d\n\x0c\n\x04\
    \x04\x1d\x02\x04\x12\x04\x8f\x01\x02\x1f\n\r\n\x05\x04\x1d\x02\x04\x05\
    \x12\x04\x8f\x01\x02\x08\n\r\n\x05\x04\x1d\x02\x04\x01\x12\x04\x8f\x01\t\
    \x1a\n\r\n\x05\x04\x1d\x02\x04\x03\x12\x04\x8f\x01\x1d\x1e\n\x0c\n\x04\
    \x04\x1d\x02\x05\x12\x04\x90\x01\x02!\n\r\n\x05\x04\x1d\x02\x05\x05\x12\
    \x04\x90\x01\x02\x08\n\r\n\x05\x04\x1d\x02\x05\x01\x12\x04\x90\x01\t\x1c\
    \n\r\n\x05\x04\x1d\x02\x05\x03\x12\x04\x90\x01\x1f\x20\n\x0c\n\x04\x04\
    \x1d\x02\x06\x12\x04\x91\x01\x02\x16\n\r\n\x05\x04\x1d\x02\x06\x05\x12\
    \x04\x91\x01\x02\x07\n\r\n\x05\x04\x1d\x02\x06\x01\x12\x04\x91\x01\x08\
    \x11\n\r\n\x05\x04\x1d\x02\x06\x03\x12\x04\x91\x01\x14\x15\n\x0c\n\x04\
    \x04\x1d\x02\x07\x12\x04\x92\x01\x02\x14\n\r\n\x05\x04\x1d\x02\x07\x05\
    \x12\x04\x92\x01\x02\x08\n\r\n\x05\x04\x1d\x02\x07\x01\x12\x04\x92\x01\t\
    \x0f\n\r\n\x05\x04\x1d\x02\x07\x03\x12\x04\x92\x01\x12\x13\n\x0c\n\x04\
    \x04\x1d\x02\x08\x12\x04\x93\x01\x02\"\n\r\n\x05\x04\x1d\x02\x08\x05\x12\
    \x04\x93\x01\x02\x08\n\r\n\x05\x04\x1d\x02\x08\x01\x12\x04\x93\x01\t\x1d\
    \n\r\n\x05\x04\x1d\x02\x08\x03\x12\x04\x93\x01\x20!\n\x0c\n\x04\x04\x1d\
    \x02\t\x12\x04\x94\x01\x02\x16\n\r\n\x05\x04\x1d\x02\t\x05\x12\x04\x94\
    \x01\x02\x08\n\r\n\x05\x04\x1d\x02\t\x01\x12\x04\x94\x01\t\x10\n\r\n\x05\
    \x04\x1d\x02\t\x03\x12\x04\x94\x01\x13\x15\n\x0c\n\x02\x04\x1e\x12\x06\
    \x96\x01\0\x98\x01\x01\n\x0b\n\x03\x04\x1e\x01\x12\x04\x96\x01\x08+\n\
    \x0c\n\x04\x04\x1e\x02\0\x12\x04\x97\x01\x02\x1b\n\r\n\x05\x04\x1e\x02\0\
    \x05\x12\x04\x97\x01\x02\x07\n\r\n\x05\x04\x1e\x02\0\x01\x12\x04\x97\x01\
    \x08\x16\n\r\n\x05\x04\x1e\x02\0\x03\x12\x04\x97\x01\x19\x1a\n\x0c\n\x02\
    \x04\x1f\x12\x06\x9a\x01\0\x9f\x01\x01\n\x0b\n\x03\x04\x1f\x01\x12\x04\
    \x9a\x01\x08\x1c\n\x0c\n\x04\x04\x1f\x02\0\x12\x04\x9b\x01\x02\x18\n\r\n\
    \x05\x04\x1f\x02\0\x05\x12\x04\x9b\x01\x02\x07\n\r\n\x05\x04\x1f\x02\0\
    \x01\x12\x04\x9b\x01\x08\x13\n\r\n\x05\x04\x1f\x02\0\x03\x12\x04\x9b\x01\
    \x16\x17\n\x0c\n\x04\x04\x1f\x02\x01\x12\x04\x9c\x01\x02\x1e\n\r\n\x05\
    \x04\x1f\x02\x01\x05\x12\x04\x9c\x01\x02\x08\n\r\n\x05\x04\x1f\x02\x01\
    \x01\x12\x04\x9c\x01\t\x19\n\r\n\x05\x04\x1f\x02\x01\x03\x12\x04\x9c\x01\
    \x1c\x1d\n\x0c\n\x04\x04\x1f\x02\x02\x12\x04\x9d\x01\x02!\n\r\n\x05\x04\
    \x1f\x02\x02\x05\x12\x04\x9d\x01\x02\x08\n\r\n\x05\x04\x1f\x02\x02\x01\
    \x12\x04\x9d\x01\t\x1c\n\r\n\x05\x04\x1f\x02\x02\x03\x12\x04\x9d\x01\x1f\
    \x20\n\x0c\n\x04\x04\x1f\x02\x03\x12\x04\x9e\x01\x02$\n\r\n\x05\x04\x1f\
    \x02\x03\x04\x12\x04\x9e\x01\x02\n\n\r\n\x05\x04\x1f\x02\x03\x05\x12\x04\
    \x9e\x01\x0b\x10\n\r\n\x05\x04\x1f\x02\x03\x01\x12\x04\x9e\x01\x11\x1f\n\
    \r\n\x05\x04\x1f\x02\x03\x03\x12\x04\x9e\x01\"#\n\x0c\n\x02\x04\x20\x12\
    \x06\xa0\x01\0\xa2\x01\x01\n\x0b\n\x03\x04\x20\x01\x12\x04\xa0\x01\x08$\
    \n\x0c\n\x04\x04\x20\x02\0\x12\x04\xa1\x01\x02\x1b\n\r\n\x05\x04\x20\x02\
    \0\x05\x12\x04\xa1\x01\x02\x06\n\r\n\x05\x04\x20\x02\0\x01\x12\x04\xa1\
    \x01\x07\x16\n\r\n\x05\x04\x20\x02\0\x03\x12\x04\xa1\x01\x19\x1a\n\x0c\n\
    \x02\x04!\x12\x06\xa4\x01\0\xa7\x01\x01\n\x0b\n\x03\x04!\x01\x12\x04\xa4\
    \x01\x08\x20\n\x0c\n\x04\x04!\x02\0\x12\x04\xa5\x01\x02\x18\n\r\n\x05\
    \x04!\x02\0\x05\x12\x04\xa5\x01\x02\x07\n\r\n\x05\x04!\x02\0\x01\x12\x04\
    \xa5\x01\x08\x13\n\r\n\x05\x04!\x02\0\x03\x12\x04\xa5\x01\x16\x17\n\x0c\
    \n\x04\x04!\x02\x01\x12\x04\xa6\x01\x02\x1a\n\r\n\x05\x04!\x02\x01\x05\
    \x12\x04\xa6\x01\x02\x07\n\r\n\x05\x04!\x02\x01\x01\x12\x04\xa6\x01\x08\
    \x15\n\r\n\x05\x04!\x02\x01\x03\x12\x04\xa6\x01\x18\x19\n\xf1\x01\n\x02\
    \x04\"\x12\x06\xab\x01\0\xc0\x01\x01\x1a\xe2\x01\x20VerificationDetails\
    \x20must\x20have\x20same\x20members\x20with\x20VerificationDetails\x20in\
    \x20\"sgxvm/proto/ffi.proto\"\n\x20including\x20verification\x20type\x20\
    and\x20verification\x20id\x20as\x20key.\n\x20But\x20the\x20member\x20typ\
    es\x20can\x20be\x20different,\x20such\x20as\x20string(address)\x20to\x20\
    bytes\n\n\x0b\n\x03\x04\"\x01\x12\x04\xab\x01\x08\x1b\n!\n\x04\x04\"\x02\
    \0\x12\x04\xad\x01\x02\x1e\x1a\x13\x20Verification\x20type\n\n\r\n\x05\
    \x04\"\x02\0\x05\x12\x04\xad\x01\x02\x08\n\r\n\x05\x04\"\x02\0\x01\x12\
    \x04\xad\x01\t\x19\n\r\n\x05\x04\"\x02\0\x03\x12\x04\xad\x01\x1c\x1d\n\
    \x1f\n\x04\x04\"\x02\x01\x12\x04\xaf\x01\x02\x1b\x1a\x11\x20Verification\
    \x20Id\n\n\r\n\x05\x04\"\x02\x01\x05\x12\x04\xaf\x01\x02\x07\n\r\n\x05\
    \x04\"\x02\x01\x01\x12\x04\xaf\x01\x08\x16\n\r\n\x05\x04\"\x02\x01\x03\
    \x12\x04\xaf\x01\x19\x1a\n+\n\x04\x04\"\x02\x02\x12\x04\xb1\x01\x02\x1a\
    \x1a\x1d\x20Verification\x20issuer\x20address\n\n\r\n\x05\x04\"\x02\x02\
    \x05\x12\x04\xb1\x01\x02\x07\n\r\n\x05\x04\"\x02\x02\x01\x12\x04\xb1\x01\
    \x08\x15\n\r\n\x05\x04\"\x02\x02\x03\x12\x04\xb1\x01\x18\x19\n6\n\x04\
    \x04\"\x02\x03\x12\x04\xb3\x01\x02\x19\x1a(\x20From\x20which\x20chain\
    \x20proof\x20was\x20transferred\n\n\r\n\x05\x04\"\x02\x03\x05\x12\x04\
    \xb3\x01\x02\x08\n\r\n\x05\x04\"\x02\x03\x01\x12\x04\xb3\x01\t\x14\n\r\n\
    \x05\x04\"\x02\x03\x03\x12\x04\xb3\x01\x17\x18\n+\n\x04\x04\"\x02\x04\
    \x12\x04\xb5\x01\x02\x1f\x1a\x1d\x20Original\x20issuance\x20timestamp\n\
    \n\r\n\x05\x04\"\x02\x04\x05\x12\x04\xb5\x01\x02\x08\n\r\n\x05\x04\"\x02\
    \x04\x01\x12\x04\xb5\x01\t\x1a\n\r\n\x05\x04\"\x02\x04\x03\x12\x04\xb5\
    \x01\x1d\x1e\n-\n\x04\x04\"\x02\x05\x12\x04\xb7\x01\x02!\x1a\x1f\x20Orig\
    inal\x20expiration\x20timestamp\n\n\r\n\x05\x04\"\x02\x05\x05\x12\x04\
    \xb7\x01\x02\x08\n\r\n\x05\x04\"\x02\x05\x01\x12\x04\xb7\x01\t\x1c\n\r\n\
    \x05\x04\"\x02\x05\x03\x12\x04\xb7\x01\x1f\x20\n.\n\x04\x04\"\x02\x06\
    \x12\x04\xb9\x01\x02\x19\x1a\x20\x20Original\x20proof\x20data\x20(ZK-pro\
    of)\n\n\r\n\x05\x04\"\x02\x06\x05\x12\x04\xb9\x01\x02\x07\n\r\n\x05\x04\
    \"\x02\x06\x01\x12\x04\xb9\x01\x08\x14\n\r\n\x05\x04\"\x02\x06\x03\x12\
    \x04\xb9\x01\x17\x18\n(\n\x04\x04\"\x02\x07\x12\x04\xbb\x01\x02\x14\x1a\
    \x1a\x20ZK-proof\x20original\x20schema\n\n\r\n\x05\x04\"\x02\x07\x05\x12\
    \x04\xbb\x01\x02\x08\n\r\n\x05\x04\"\x02\x07\x01\x12\x04\xbb\x01\t\x0f\n\
    \r\n\x05\x04\"\x02\x07\x03\x12\x04\xbb\x01\x12\x13\nN\n\x04\x04\"\x02\
    \x08\x12\x04\xbd\x01\x02\"\x1a@\x20Verification\x20id\x20for\x20checking\
    (KYC/KYB/AML\x20etc)\x20from\x20issuer\x20side\n\n\r\n\x05\x04\"\x02\x08\
    \x05\x12\x04\xbd\x01\x02\x08\n\r\n\x05\x04\"\x02\x08\x01\x12\x04\xbd\x01\
    \t\x1d\n\r\n\x05\x04\"\x02\x08\x03\x12\x04\xbd\x01\x20!\n\x17\n\x04\x04\
    \"\x02\t\x12\x04\xbf\x01\x02\x16\x1a\t\x20Version\n\n\r\n\x05\x04\"\x02\
    \t\x05\x12\x04\xbf\x01\x02\x08\n\r\n\x05\x04\"\x02\t\x01\x12\x04\xbf\x01\
    \t\x10\n\r\n\x05\x04\"\x02\t\x03\x12\x04\xbf\x01\x13\x15\n\x0c\n\x02\x04\
    #\x12\x06\xc1\x01\0\xc3\x01\x01\n\x0b\n\x03\x04#\x01\x12\x04\xc1\x01\x08\
    (\n\x0c\n\x04\x04#\x02\0\x12\x04\xc2\x01\x02(\n\r\n\x05\x04#\x02\0\x04\
    \x12\x04\xc2\x01\x02\n\n\r\n\x05\x04#\x02\0\x06\x12\x04\xc2\x01\x0b\x1e\
    \n\r\n\x05\x04#\x02\0\x01\x12\x04\xc2\x01\x1f#\n\r\n\x05\x04#\x02\0\x03\
    \x12\x04\xc2\x01&'\n\x0c\n\x02\x04$\x12\x06\xc5\x01\0\xd6\x01\x01\n\x0b\
    \n\x03\x04$\x01\x12\x04\xc5\x01\x08\x15\n\x0e\n\x04\x04$\x08\0\x12\x06\
    \xc6\x01\x02\xd5\x01\x03\n\r\n\x05\x04$\x08\0\x01\x12\x04\xc6\x01\x08\
    \x0b\n\x0c\n\x04\x04$\x02\0\x12\x04\xc7\x01\x04#\n\r\n\x05\x04$\x02\0\
    \x06\x12\x04\xc7\x01\x04\x13\n\r\n\x05\x04$\x02\0\x01\x12\x04\xc7\x01\
    \x14\x1e\n\r\n\x05\x04$\x02\0\x03\x12\x04\xc7\x01!\"\n\x0c\n\x04\x04$\
    \x02\x01\x12\x04\xc8\x01\x04)\n\r\n\x05\x04$\x02\x01\x06\x12\x04\xc8\x01\
    \x04\x16\n\r\n\x05\x04$\x02\x01\x01\x12\x04\xc8\x01\x17$\n\r\n\x05\x04$\
    \x02\x01\x03\x12\x04\xc8\x01'(\n\x0c\n\x04\x04$\x02\x02\x12\x04\xc9\x01\
    \x04%\n\r\n\x05\x04$\x02\x02\x06\x12\x04\xc9\x01\x04\x14\n\r\n\x05\x04$\
    \x02\x02\x01\x12\x04\xc9\x01\x15\x20\n\r\n\x05\x04$\x02\x02\x03\x12\x04\
    \xc9\x01#$\n\x0c\n\x04\x04$\x02\x03\x12\x04\xca\x01\x04(\n\r\n\x05\x04$\
    \x02\x03\x06\x12\x04\xca\x01\x04\x17\n\r\n\x05\x04$\x02\x03\x01\x12\x04\
    \xca\x01\x18#\n\r\n\x05\x04$\x02\x03\x03\x12\x04\xca\x01&'\n\x0c\n\x04\
    \x04$\x02\x04\x12\x04\xcb\x01\x04/\n\r\n\x05\x04$\x02\x04\x06\x12\x04\
    \xcb\x01\x04\x1e\n\r\n\x05\x04$\x02\x04\x01\x12\x04\xcb\x01\x1f*\n\r\n\
    \x05\x04$\x02\x04\x03\x12\x04\xcb\x01-.\n\x0c\n\x04\x04$\x02\x05\x12\x04\
    \xcc\x01\x041\n\r\n\x05\x04$\x02\x05\x06\x12\x04\xcc\x01\x04\x1a\n\r\n\
    \x05\x04$\x02\x05\x01\x12\x04\xcc\x01\x1b,\n\r\n\x05\x04$\x02\x05\x03\
    \x12\x04\xcc\x01/0\n\x0c\n\x04\x04$\x02\x06\x12\x04\xcd\x01\x041\n\r\n\
    \x05\x04$\x02\x06\x06\x12\x04\xcd\x01\x04\x1a\n\r\n\x05\x04$\x02\x06\x01\
    \x12\x04\xcd\x01\x1b,\n\r\n\x05\x04$\x02\x06\x03\x12\x04\xcd\x01/0\n\x0c\
    \n\x04\x04$\x02\x07\x12\x04\xce\x01\x04\x1b\n\r\n\x05\x04$\x02\x07\x06\
    \x12\x04\xce\x01\x04\x0f\n\r\n\x05\x04$\x02\x07\x01\x12\x04\xce\x01\x10\
    \x16\n\r\n\x05\x04$\x02\x07\x03\x12\x04\xce\x01\x19\x1a\n\x0c\n\x04\x04$\
    \x02\x08\x12\x04\xcf\x01\x041\n\r\n\x05\x04$\x02\x08\x06\x12\x04\xcf\x01\
    \x04\x1a\n\r\n\x05\x04$\x02\x08\x01\x12\x04\xcf\x01\x1b,\n\r\n\x05\x04$\
    \x02\x08\x03\x12\x04\xcf\x01/0\n\x0c\n\x04\x04$\x02\t\x12\x04\xd0\x01\
    \x04*\n\r\n\x05\x04$\x02\t\x06\x12\x04\xd0\x01\x04\x16\n\r\n\x05\x04$\
    \x02\t\x01\x12\x04\xd0\x01\x17$\n\r\n\x05\x04$\x02\t\x03\x12\x04\xd0\x01\
    ')\n\x0c\n\x04\x04$\x02\n\x12\x04\xd1\x01\x04\"\n\r\n\x05\x04$\x02\n\x06\
    \x12\x04\xd1\x01\x04\x12\n\r\n\x05\x04$\x02\n\x01\x12\x04\xd1\x01\x13\
    \x1c\n\r\n\x05\x04$\x02\n\x03\x12\x04\xd1\x01\x1f!\n\x0c\n\x04\x04$\x02\
    \x0b\x12\x04\xd2\x01\x04<\n\r\n\x05\x04$\x02\x0b\x06\x12\x04\xd2\x01\x04\
    \x1f\n\r\n\x05\x04$\x02\x0b\x01\x12\x04\xd2\x01\x206\n\r\n\x05\x04$\x02\
    \x0b\x03\x12\x04\xd2\x019;\n\x0c\n\x04\x04$\x02\x0c\x12\x04\xd3\x01\x04.\
    \n\r\n\x05\x04$\x02\x0c\x06\x12\x04\xd3\x01\x04\x18\n\r\n\x05\x04$\x02\
    \x0c\x01\x12\x04\xd3\x01\x19(\n\r\n\x05\x04$\x02\x0c\x03\x12\x04\xd3\x01\
    +-\n\x0c\n\x04\x04$\x02\r\x12\x04\xd4\x01\x046\n\r\n\x05\x04$\x02\r\x06\
    \x12\x04\xd4\x01\x04\x1c\n\r\n\x05\x04$\x02\r\x01\x12\x04\xd4\x01\x1d0\n\
    \r\n\x05\x04$\x02\r\x03\x12\x04\xd4\x0135\nF\n\x02\x04%\x12\x06\xd9\x01\
    \0\xe2\x01\x01\x1a8\x20Message\x20with\x20data\x20required\x20to\x20exec\
    ute\x20`call`\x20operation\n\n\x0b\n\x03\x04%\x01\x12\x04\xd9\x01\x08\
    \x17\n\x0c\n\x04\x04%\x02\0\x12\x04\xda\x01\x02\x11\n\r\n\x05\x04%\x02\0\
    \x05\x12\x04\xda\x01\x02\x07\n\r\n\x05\x04%\x02\0\x01\x12\x04\xda\x01\
    \x08\x0c\n\r\n\x05\x04%\x02\0\x03\x12\x04\xda\x01\x0f\x10\n\x0c\n\x04\
    \x04%\x02\x01\x12\x04\xdb\x01\x02\x0f\n\r\n\x05\x04%\x02\x01\x05\x12\x04\
    \xdb\x01\x02\x07\n\r\n\x05\x04%\x02\x01\x01\x12\x04\xdb\x01\x08\n\n\r\n\
    \x05\x04%\x02\x01\x03\x12\x04\xdb\x01\r\x0e\n\x0c\n\x04\x04%\x02\x02\x12\
    \x04\xdc\x01\x02\x11\n\r\n\x05\x04%\x02\x02\x05\x12\x04\xdc\x01\x02\x07\
    \n\r\n\x05\x04%\x02\x02\x01\x12\x04\xdc\x01\x08\x0c\n\r\n\x05\x04%\x02\
    \x02\x03\x12\x04\xdc\x01\x0f\x10\n\x0c\n\x04\x04%\x02\x03\x12\x04\xdd\
    \x01\x02\x16\n\r\n\x05\x04%\x02\x03\x05\x12\x04\xdd\x01\x02\x08\n\r\n\
    \x05\x04%\x02\x03\x01\x12\x04\xdd\x01\t\x11\n\r\n\x05\x04%\x02\x03\x03\
    \x12\x04\xdd\x01\x14\x15\n\x0c\n\x04\x04%\x02\x04\x12\x04\xde\x01\x02\
    \x12\n\r\n\x05\x04%\x02\x04\x05\x12\x04\xde\x01\x02\x07\n\r\n\x05\x04%\
    \x02\x04\x01\x12\x04\xde\x01\x08\r\n\r\n\x05\x04%\x02\x04\x03\x12\x04\
    \xde\x01\x10\x11\n\x0c\n\x04\x04%\x02\x05\x12\x04\xdf\x01\x02)\n\r\n\x05\
    \x04%\x02\x05\x04\x12\x04\xdf\x01\x02\n\n\r\n\x05\x04%\x02\x05\x06\x12\
    \x04\xdf\x01\x0b\x19\n\r\n\x05\x04%\x02\x05\x01\x12\x04\xdf\x01\x1a$\n\r\
    \n\x05\x04%\x02\x05\x03\x12\x04\xdf\x01'(\n\x0c\n\x04\x04%\x02\x06\x12\
    \x04\xe0\x01\x02\x12\n\r\n\x05\x04%\x02\x06\x05\x12\x04\xe0\x01\x02\x06\
    \n\r\n\x05\x04%\x02\x06\x01\x12\x04\xe0\x01\x07\r\n\r\n\x05\x04%\x02\x06\
    \x03\x12\x04\xe0\x01\x10\x11\n\x0c\n\x04\x04%\x02\x07\x12\x04\xe1\x01\
    \x02\x13\n\r\n\x05\x04%\x02\x07\x05\x12\x04\xe1\x01\x02\x08\n\r\n\x05\
    \x04%\x02\x07\x01\x12\x04\xe1\x01\t\x0e\n\r\n\x05\x04%\x02\x07\x03\x12\
    \x04\xe1\x01\x11\x12\nH\n\x02\x04&\x12\x06\xe5\x01\0\xed\x01\x01\x1a:\
    \x20Message\x20with\x20data\x20required\x20to\x20execute\x20`create`\x20\
    operation\n\n\x0b\n\x03\x04&\x01\x12\x04\xe5\x01\x08\x19\n\x0c\n\x04\x04\
    &\x02\0\x12\x04\xe6\x01\x02\x11\n\r\n\x05\x04&\x02\0\x05\x12\x04\xe6\x01\
    \x02\x07\n\r\n\x05\x04&\x02\0\x01\x12\x04\xe6\x01\x08\x0c\n\r\n\x05\x04&\
    \x02\0\x03\x12\x04\xe6\x01\x0f\x10\n\x0c\n\x04\x04&\x02\x01\x12\x04\xe7\
    \x01\x02\x11\n\r\n\x05\x04&\x02\x01\x05\x12\x04\xe7\x01\x02\x07\n\r\n\
    \x05\x04&\x02\x01\x01\x12\x04\xe7\x01\x08\x0c\n\r\n\x05\x04&\x02\x01\x03\
    \x12\x04\xe7\x01\x0f\x10\n\x0c\n\x04\x04&\x02\x02\x12\x04\xe8\x01\x02\
    \x16\n\r\n\x05\x04&\x02\x02\x05\x12\x04\xe8\x01\x02\x08\n\r\n\x05\x04&\
    \x02\x02\x01\x12\x04\xe8\x01\t\x11\n\r\n\x05\x04&\x02\x02\x03\x12\x04\
    \xe8\x01\x14\x15\n\x0c\n\x04\x04&\x02\x03\x12\x04\xe9\x01\x02\x12\n\r\n\
    \x05\x04&\x02\x03\x05\x12\x04\xe9\x01\x02\x07\n\r\n\x05\x04&\x02\x03\x01\
    \x12\x04\xe9\x01\x08\r\n\r\n\x05\x04&\x02\x03\x03\x12\x04\xe9\x01\x10\
    \x11\n\x0c\n\x04\x04&\x02\x04\x12\x04\xea\x01\x02)\n\r\n\x05\x04&\x02\
    \x04\x04\x12\x04\xea\x01\x02\n\n\r\n\x05\x04&\x02\x04\x06\x12\x04\xea\
    \x01\x0b\x19\n\r\n\x05\x04&\x02\x04\x01\x12\x04\xea\x01\x1a$\n\r\n\x05\
    \x04&\x02\x04\x03\x12\x04\xea\x01'(\n\x0c\n\x04\x04&\x02\x05\x12\x04\xeb\
    \x01\x02\x12\n\r\n\x05\x04&\x02\x05\x05\x12\x04\xeb\x01\x02\x06\n\r\n\
    \x05\x04&\x02\x05\x01\x12\x04\xeb\x01\x07\r\n\r\n\x05\x04&\x02\x05\x03\
    \x12\x04\xeb\x01\x10\x11\n\x0c\n\x04\x04&\x02\x06\x12\x04\xec\x01\x02\
    \x13\n\r\n\x05\x04&\x02\x06\x05\x12\x04\xec\x01\x02\x08\n\r\n\x05\x04&\
    \x02\x06\x01\x12\x04\xec\x01\t\x0e\n\r\n\x05\x04&\x02\x06\x03\x12\x04\
    \xec\x01\x11\x12\n3\n\x02\x04'\x12\x06\xf0\x01\0\xf3\x01\x01\x1a%\x20Req\
    uest\x20to\x20execute\x20`call`\x20operation\n\n\x0b\n\x03\x04'\x01\x12\
    \x04\xf0\x01\x08\x18\n\x0c\n\x04\x04'\x02\0\x12\x04\xf1\x01\x02\x1d\n\r\
    \n\x05\x04'\x02\0\x06\x12\x04\xf1\x01\x02\x11\n\r\n\x05\x04'\x02\0\x01\
    \x12\x04\xf1\x01\x12\x18\n\r\n\x05\x04'\x02\0\x03\x12\x04\xf1\x01\x1b\
    \x1c\n\x0c\n\x04\x04'\x02\x01\x12\x04\xf2\x01\x02!\n\r\n\x05\x04'\x02\
    \x01\x06\x12\x04\xf2\x01\x02\x14\n\r\n\x05\x04'\x02\x01\x01\x12\x04\xf2\
    \x01\x15\x1c\n\r\n\x05\x04'\x02\x01\x03\x12\x04\xf2\x01\x1f\x20\n5\n\x02\
    \x04(\x12\x06\xf6\x01\0\xf9\x01\x01\x1a'\x20Request\x20to\x20execute\x20\
    `create`\x20operation\n\n\x0b\n\x03\x04(\x01\x12\x04\xf6\x01\x08\x1a\n\
    \x0c\n\x04\x04(\x02\0\x12\x04\xf7\x01\x02\x1f\n\r\n\x05\x04(\x02\0\x06\
    \x12\x04\xf7\x01\x02\x13\n\r\n\x05\x04(\x02\0\x01\x12\x04\xf7\x01\x14\
    \x1a\n\r\n\x05\x04(\x02\0\x03\x12\x04\xf7\x01\x1d\x1e\n\x0c\n\x04\x04(\
    \x02\x01\x12\x04\xf8\x01\x02!\n\r\n\x05\x04(\x02\x01\x06\x12\x04\xf8\x01\
    \x02\x14\n\r\n\x05\x04(\x02\x01\x01\x12\x04\xf8\x01\x15\x1c\n\r\n\x05\
    \x04(\x02\x01\x03\x12\x04\xf8\x01\x1f\x20\n1\n\x02\x04)\x12\x06\xfc\x01\
    \0\xfe\x01\x01\x1a#\x20Request\x20to\x20obtain\x20node\x20public\x20key\
    \n\n\x0b\n\x03\x04)\x01\x12\x04\xfc\x01\x08\x1c\n\x0c\n\x04\x04)\x02\0\
    \x12\x04\xfd\x01\x02\x19\n\r\n\x05\x04)\x02\0\x05\x12\x04\xfd\x01\x02\
    \x08\n\r\n\x05\x04)\x02\0\x01\x12\x04\xfd\x01\t\x14\n\r\n\x05\x04)\x02\0\
    \x03\x12\x04\xfd\x01\x17\x18\n+\n\x02\x04*\x12\x04\x81\x02\06\x1a\x1f\
    \x20Response\x20with\x20node\x20public\x20key\n\n\x0b\n\x03\x04*\x01\x12\
    \x04\x81\x02\x08\x1d\n\x0c\n\x04\x04*\x02\0\x12\x04\x81\x02\x204\n\r\n\
    \x05\x04*\x02\0\x05\x12\x04\x81\x02\x20%\n\r\n\x05\x04*\x02\0\x01\x12\
    \x04\x81\x02&/\n\r\n\x05\x04*\x02\0\x03\x12\x04\x81\x0223\n\x0c\n\x02\
    \x04+\x12\x06\x83\x02\0\x87\x02\x01\n\x0b\n\x03\x04+\x01\x12\x04\x83\x02\
    \x08\x11\n\x0c\n\x04\x04+\x02\0\x12\x04\x84\x02\x02\x19\n\r\n\x05\x04+\
    \x02\0\x05\x12\x04\x84\x02\x02\x08\n\r\n\x05\x04+\x02\0\x01\x12\x04\x84\
    \x02\t\x14\n\r\n\x05\x04+\x02\0\x03\x12\x04\x84\x02\x17\x18\n\x0c\n\x04\
    \x04+\x02\x01\x12\x04\x85\x02\x02\x1b\n\r\n\x05\x04+\x02\x01\x05\x12\x04\
    \x85\x02\x02\x08\n\r\n\x05\x04+\x02\x01\x01\x12\x04\x85\x02\t\x16\n\r\n\
    \x05\x04+\x02\x01\x03\x12\x04\x85\x02\x19\x1a\n\x0c\n\x04\x04+\x02\x02\
    \x12\x04\x86\x02\x02\x1a\n\r\n\x05\x04+\x02\x02\x05\x12\x04\x86\x02\x02\
    \x07\n\r\n\x05\x04+\x02\x02\x01\x12\x04\x86\x02\x08\x15\n\r\n\x05\x04+\
    \x02\x02\x03\x12\x04\x86\x02\x18\x19\n\x0c\n\x02\x04,\x12\x06\x88\x02\0\
    \x8a\x02\x01\n\x0b\n\x03\x04,\x01\x12\x04\x88\x02\x08\x1a\n\x0c\n\x04\
    \x04,\x02\0\x12\x04\x89\x02\x02\x20\n\r\n\x05\x04,\x02\0\x04\x12\x04\x89\
    \x02\x02\n\n\r\n\x05\x04,\x02\0\x06\x12\x04\x89\x02\x0b\x14\n\r\n\x05\
    \x04,\x02\0\x01\x12\x04\x89\x02\x15\x1b\n\r\n\x05\x04,\x02\0\x03\x12\x04\
    \x89\x02\x1e\x1f\n\x0c\n\x02\x04-\x12\x06\x8c\x02\0\x92\x02\x01\n\x0b\n\
    \x03\x04-\x01\x12\x04\x8c\x02\x08\x12\n\x0e\n\x04\x04-\x08\0\x12\x06\x8d\
    \x02\x02\x91\x02\x03\n\r\n\x05\x04-\x08\0\x01\x12\x04\x8d\x02\x08\x0b\n\
    \x0c\n\x04\x04-\x02\0\x12\x04\x8e\x02\x04%\n\r\n\x05\x04-\x02\0\x06\x12\
    \x04\x8e\x02\x04\x14\n\r\n\x05\x04-\x02\0\x01\x12\x04\x8e\x02\x15\x20\n\
    \r\n\x05\x04-\x02\0\x03\x12\x04\x8e\x02#$\n\x0c\n\x04\x04-\x02\x01\x12\
    \x04\x8f\x02\x04)\n\r\n\x05\x04-\x02\x01\x06\x12\x04\x8f\x02\x04\x16\n\r\
    \n\x05\x04-\x02\x01\x01\x12\x04\x8f\x02\x17$\n\r\n\x05\x04-\x02\x01\x03\
    \x12\x04\x8f\x02'(\n\x0c\n\x04\x04-\x02\x02\x12\x04\x90\x02\x04.\n\r\n\
    \x05\x04-\x02\x02\x06\x12\x04\x90\x02\x04\x18\n\r\n\x05\x04-\x02\x02\x01\
    \x12\x04\x90\x02\x19)\n\r\n\x05\x04-\x02\x02\x03\x12\x04\x90\x02,-b\x06p\
    roto3\
";

static mut file_descriptor_proto_lazy: ::protobuf::lazy::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::lazy::Lazy {
    lock: ::protobuf::lazy::ONCE_INIT,
    ptr: 0 as *const ::protobuf::descriptor::FileDescriptorProto,
};

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    unsafe {
        file_descriptor_proto_lazy.get(|| {
            parse_descriptor_proto()
        })
    }
}
