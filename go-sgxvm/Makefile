SHELL := /bin/bash
COMPILER = rustc
TARGET = $(shell rustc --version --verbose 2> /dev/null | awk "/host:/ { print \$$2 }")
TARGET_DIR = target/release/
DEFAULT = help
CC=clang
CXX=clang++
SGX_MODE ?= HW
ENCLAVE_HOME ?= $(HOME)/.swisstronik-enclave

Trts_Library_Name = sgx_trts
Service_Library_Name = sgx_tservice
Enclave_build_feature = hardware_mode

# ENCLAVE SETTINGS
ifneq ($(SGX_MODE), HW)
	Trts_Library_Name := sgx_trts_sim
	Service_Library_Name := sgx_tservice_sim
	Enclave_build_feature := simulation_mode
else
	Trts_Library_Name := sgx_trts
	Service_Library_Name := sgx_tservice
	Enclave_build_feature := hardware_mode
endif

# DEFINEs

define sgx_clean
	@echo "Cleaning enclave dependencies"
	@rm -rf ./sgx-artifacts/bin/*
	@rm -rf ./sgx-artifacts/lib/*
	@rm -f ./Enclave_u*
	@rm -rf ./sgx-evm/target
	@rm -f ./sgx-evm/Enclave_t*
	@rm -f ./sgx-evm/enclave.unsigned.so
endef

define compile_protobuf
	@echo "Compiling protobuf files for enclave"
    protoc --rust_out sgx-evm/src/protobuf_generated/ ./sgx-evm/protobuf_contracts/ffi.proto
    sed -i -e 's/use protobuf::Message as/\n\nuse std::prelude::v1::*;\nuse protobuf::Message as/g' ./sgx-evm/src/protobuf_generated/ffi.rs
endef

define compile_wrapper_protobuf
	@echo "Compiling protobuf files for wrapper"
    protoc --rust_out sgx-wrapper/src/protobuf_generated/ ./sgx-wrapper/protobuf_contracts/node.proto
endef

define compile_enclave_rust
	@echo "Building enclave rust code"
	@CARGO_TARGET_DIR=./sgx-evm/target RUSTFLAGS="-C target-cpu=native" cargo build --release --features $(Enclave_build_feature) --no-default-features --manifest-path ./sgx-evm/Cargo.toml
endef

define create_bridge_enclave_rust
	@echo "Create bridge between enclave and rust"
	@/opt/intel/sgxsdk/bin/x64/sgx_edger8r --trusted ./sgx-evm/Enclave.edl --search-path /opt/intel/sgxsdk/include --search-path ./sgx-sdk/edl --trusted-dir ./sgx-evm
	@/opt/intel/sgxsdk/bin/x64/sgx_edger8r --untrusted ./sgx-evm/Enclave.edl --search-path /opt/intel/sgxsdk/include --search-path ./sgx-sdk/edl --untrusted-dir ./
endef

define compile_enclave_bridge
    @echo "Compile files generated by sgx_edger8r using cc"
	@cc -m64 -O2 -fstack-protector -fPIC -Wno-attributes -I ./ -I./include -I/opt/intel/sgxsdk/include -I./sgx-sdk/edl -c ./Enclave_u.c -o ./Enclave_u.o
endef

define create_archive
	@echo "Compress files"
	@ar rcsD ./sgx-artifacts/lib/libEnclave_u.a ./Enclave_u.o
endef

define copy_compiled_enclave
 	@echo "Copy compiled enclave files"
	@cp ./sgx-evm/target/release/libenclave.a ./sgx-artifacts/lib/libenclave.a
endef

define compile_into_enclave_t_o
	@echo "Compile into Enclave_t.o"
	@cc -m64 -O2 -fstack-protector -ffreestanding -nostdinc -fvisibility=hidden -fpie -fno-strict-overflow -fno-delete-null-pointer-checks -I./sgx-sdk/common/inc -I./sgx-sdk/edl -I/opt/intel/sgxsdk/include -I/opt/intel/sgxsdk/include/tlibc -I/opt/intel/sgxsdk/include/stlport -I/opt/intel/sgxsdk/include/epid -I ./sgx-evm -I./include -c ./sgx-evm/Enclave_t.c -o ./sgx-evm/Enclave_t.o
endef

define compile_unsigned_enclave
	@echo "Compile into unsinged enclave"
	@g++ ./sgx-evm/Enclave_t.o -o ./sgx-evm/enclave.unsigned.so -Wl,--no-undefined -nostdlib -nodefaultlibs -nostartfiles -L/opt/intel/sgxsdk/lib64 \
		-Wl,--whole-archive -l$(Trts_Library_Name) -Wl,--no-whole-archive -Wl,--start-group -lsgx_tstdc -lsgx_tcxx -l$(Service_Library_Name) -lsgx_tcrypto -lsgx_tprotected_fs -lpthread \
		-L./sgx-artifacts/lib -lenclave -Wl,--end-group -Wl,--version-script=./sgx-evm/Enclave.lds -Wl,-z,relro,-z,now,-z,noexecstack -Wl,-Bstatic -Wl,-Bsymbolic \
		-Wl,--no-undefined -Wl,-pie,-eenclave_entry -Wl,--export-dynamic -Wl,--gc-sections -Wl,--defsym,__ImageBase=0
endef

define sign_enclave
	@echo "Sign enclave"
	@/opt/intel/sgxsdk/bin/x64/sgx_sign sign -key ./sgx-evm/Enclave_private.pem -enclave ./sgx-evm/enclave.unsigned.so -out ./sgx-artifacts/bin/enclave.signed.so -config ./sgx-evm/Enclave.config.xml
endef

define wrapper_build
	$(call compile_wrapper_protobuf)
	@cd sgx-wrapper && ENCLAVE_HOME=$(ENCLAVE_HOME) cargo build --release
	@mkdir -p $(ENCLAVE_HOME)
	@cp ./sgx-artifacts/bin/enclave.signed.so $(ENCLAVE_HOME)/enclave.signed.so
	@rm Enclave_u*
	$(call sgx_clean)
endef

define go_build
	@cp ./sgx-wrapper/target/release/libsgx_wrapper.so ./internal/api/libsgx_wrapper.x86_64.so
    @protoc --go_out=go_protobuf_gen --proto_path=sgx-evm/protobuf_contracts/ sgx-evm/protobuf_contracts/ffi.proto
	@protoc --go_out=go_protobuf_gen --proto_path=sgx-wrapper/protobuf_contracts/ sgx-wrapper/protobuf_contracts/node.proto
endef

define sgx_build
	$(call sgx_clean)
	$(call compile_protobuf)
	$(call compile_enclave_rust)
	$(call create_bridge_enclave_rust)
	$(call compile_enclave_bridge)
	$(call create_archive)
	$(call copy_compiled_enclave)
	$(call compile_into_enclave_t_o)
	$(call compile_unsigned_enclave)
	$(call sign_enclave)
endef

# COMMANDS

sgx:
	$(call sgx_build)
	@echo "Intel SGX enclave built and signed"

build_wrapper:
	$(call sgx_build)
	$(call wrapper_build)

build_go:
	$(call sgx_build)
	$(call wrapper_build)
	$(call go_build)

run_go:
	$(call sgx_build)
	$(call wrapper_build)
	$(call go_build)
	@go run ./cmd/demo/main.go

clean:
	$(call sgx_clean)
	@echo "Cleaning wrapper target"
	@rm -r sgx-wrapper/target
